{"meta":{"title":"MrNobody's Blog","subtitle":"保持呼吸 不要断气","description":"MrNobody","author":"Mr_Nobody","url":"http://mrnobody233.github.io","root":"/"},"pages":[{"title":"","date":"2022-05-10T05:24:24.266Z","updated":"2022-05-10T05:24:24.266Z","comments":true,"path":"about/index.html","permalink":"http://mrnobody233.github.io/about/","excerpt":"","text":"# 关于 为什么会有这个博客，因为我写的第一个 Vue 项目里面想添加一个友情链接，跳转到我的个人博客，但是我并没有博客，所以我从今天，也就是 2022 年 3 月 25 日 13:39:38 诞生了我的第一个博客。 虽然这个博客的主题很漂亮，叫做 Diaspora (已换成 shoka)，但是我写不出来，我太菜了，也许有朝一日我能写出属于自己主题的博客 # 介绍 我叫木子曰天，公的，马上就要大三了，还是一个什么都不会的废物。即使是废物也有自己的想法，在大一的时候一直在学习 JAVA，经历各种原因才确定目标，开始学习 Web 前端。梦想是用所学的东西来混口饭吃，有许多爱好，但无法保持热度，所以需要通过一生慢慢学习。 由于我是一个古怪的普通人，同时也是一个懒鬼，所以介绍就到这里结束啦。 # 技能点 亚索很厉害 (指 0-10-0) CSGO 摆烂很厉害 (马上戒) 会一些 web 前端 会踢一点足球 (由于身体太差，所以不适合运动) 可以像猴子一样到处乱爬 (身体很轻 双手能抓住的地方都可以爬上去) 骂人很厉害 (马上戒) 掐人很痛 放屁很臭 阴阳怪气 别人在我面前我可以把他帅死 (长相一般) 取名鬼才 (详细可查看友情链接)"},{"title":"categories","date":"2022-03-25T12:46:37.000Z","updated":"2022-03-25T12:46:55.821Z","comments":true,"path":"categories/index.html","permalink":"http://mrnobody233.github.io/categories/","excerpt":"","text":""},{"title":"tags","date":"2022-03-25T12:47:43.000Z","updated":"2022-03-25T12:47:59.970Z","comments":true,"path":"tags/index.html","permalink":"http://mrnobody233.github.io/tags/","excerpt":"","text":""},{"title":"","date":"2022-05-10T02:25:44.899Z","updated":"2022-05-10T02:25:44.899Z","comments":true,"path":"friends/index.html","permalink":"http://mrnobody233.github.io/friends/","excerpt":"","text":"# 好兄弟 ButterFlyFish 可能会写一些无聊的笔记或者生活。没人看应该（，但是转载需注明原作者hhhh。 果果超甜 不是博客，是网络笔记本 胃病患者 划船不用桨，一生全靠浪。 废宅充电器 生活不息，折腾不止 # 特别好看的博客 優萌初華 琉璃的医学 &amp; 编程笔记"},{"title":"search","date":"2022-03-26T13:09:20.000Z","updated":"2022-03-26T13:10:30.800Z","comments":true,"path":"search/index.html","permalink":"http://mrnobody233.github.io/search/","excerpt":"","text":""},{"title":"","date":"2022-05-18T05:12:45.405Z","updated":"2022-05-18T05:12:45.405Z","comments":true,"path":"links/index.html","permalink":"http://mrnobody233.github.io/links/","excerpt":"","text":"# 实用网站 我的文件夹里有许多使用的网站，但也只是放在文件夹里，乱七八糟，没有整理，所以现在放在这里，以后就可以更加方便的利用这些网站 # 编程类 flatuicolors 不知道如何配色可以看看介个网站 colorhunt 这个配色网站也特别好看 取名鬼才 不知道取什么变量名可以看看这个 阿里字库 不管是网页还是PS，又或者是PPT，都可以用得上，真不错 # 图片类 wallpaper壁纸 有许多挺不错的漂亮壁纸可以在这里看 搜图神器 可以搜索超清的好康的图片 主要我是荣耀捐赠会员 # 音乐类 刘志进音乐直连搜索 可以在这里搜索很多音乐 外链转换工具 可以配合左边网站获得音乐的mp3网址 # 影视类 hwj影视 可以看各种电影和番剧 (使用手机打开会有广告，推荐打开网页版 ) 寻剧吧 也是看各种电影和番剧 (使用手机打开会有广告，推荐打开网页版 ) NT动漫 看动漫，有瑟瑟的广告 bilibili 你所热爱的就是你的生活 (**陈睿 吃柠檬**) youtube 可以在里面找乐子0.0 要翻墙 # 娱乐类 今天吃什么 不知道吃什么可以看看介个 Picrew 随机生成头像，这个卡片的封面就是这里来的，是不是很好看 qwq 要翻墙 逗比拯救世界 很多各种各样的表情包，逗比必备哦。 # 其他 免费空间 学习 html css 的时候跟着pink老师找到的网站。 木子网 上传的大一下学期的期末作业，纯 html 和 css，做的好像比现在还好看许多，果然我把 css 忘光了。 查看综测分 查看综测分 学校选课 学校选修网课 # 无聊了继续更新 拜拜"}],"posts":[{"title":"Vue3-vuex","slug":"vue3-vuex","date":"2022-05-20T13:09:52.000Z","updated":"2022-05-26T09:14:45.536Z","comments":true,"path":"2022/05/20/vue3-vuex/","link":"","permalink":"http://mrnobody233.github.io/2022/05/20/vue3-vuex/","excerpt":"","text":"与 vue2 中使用方式类似，复习一下下 # state state 提供位移的公共数据源，所有共享的数据都要统一放到 Store 的 State 中进行存储 在 state 中定义一个数据 import { createStore } from 'vuex'export default createStore({ state: { username: 'zs' },})使用方法 1. 直接使用 &lt;p&gt;姓名：{ $store.state.username }&lt;/p&gt;2. 通过 vuex 仓库获取数据 // 导入import { useStore } from 'vuex'export default { name: 'app', setup() { // 使用 vuex 仓库 const store = useStore() console.log(store.state.username); },}# getters 用于对 Store 中的数据进行加工处理形成新的数据，类似 vue 中的计算属性 定义一个方法 export default createStore({ state: { username: 'zs' }, getters: { newName(state) { return state.username + '!!!' } }, mutations: { }, actions: { }, modules: { }})使用方法 直接使用 &lt;p&gt;姓名：{ $store.getters.newName }&lt;/p&gt; 从 vuex 仓库中获取数据 &lt;script&gt;import { useStore } from 'vuex'export default { name: 'app', setup() { // 使用 vuex 仓库 const store = useStore() // 获取 getters 数据 console.log(store.getters.newName); },}&lt;/script&gt;# mutations Mutation 用于变更 Store 中的数据。 只能通过 mutation 变更 Store 数据，不可以直接操作 Store 中的数据 通过这种方式虽然操作起来繁琐一些，但是可以集中监控所有数据的变化 在 mutation 中定义一个函数 import { createStore } from 'vuex'export default createStore({ state: { username: 'zs' }, getters: { newName(state) { return state.username + '!!!' } }, mutations: { updateName(state) { state.username = 'ls' } },})使用方法 store.commit('') &lt;template&gt; &lt;div&gt; &lt;!-- 1. 使用根模块 state 的数据 --&gt; &lt;p&gt;姓名：&lt;/p&gt; &lt;!-- 2. 使用根模块的 getters 的数据 --&gt; &lt;p&gt;姓名：&lt;/p&gt; &lt;button @click=\"updateName\"&gt;更改姓名&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { useStore } from 'vuex'export default { name: 'app', setup() { // 使用 vuex 仓库 const store = useStore() const updateName = () =&gt; { |----------------------------| | store.commit('updateName') | | -------------------------- | } return { updateName } },}&lt;/script&gt;# Action Action 用于处理异步任务 如果通过异步操作变更数据，必须通过 Action，而不能使用 Mutation，但是在 Action 中还是要通过触发 mutation 的方式间接变更数据。 import { createStore } from 'vuex'export default createStore({ state: { username: 'zs' }, getters: { newName(state) { return state.username + '!!!' } }, mutations: { updateName(state) { state.username = 'ls' } }, actions: { updateName(context) { setTimeout(() =&gt; { context.commit('updateName') }, 1000); } }, modules: { }})使用方法 store.dispath('mutation中的方法') &lt;script&gt;import { useStore } from 'vuex'export default { name: 'app', setup() { // 使用 vuex 仓库 const store = useStore() const updateName = () =&gt; { // 调用 actions 函数 store.dispatch('updateName') } return { updateName } },}&lt;/script&gt;# modules 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。 为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块 —— 从上至下进行同样方式的分割 # 简略一些 好像是挺简单的，可以复杂一点，但是看得更加清晰，那么开始吧 在 store 文件下新建一个 modules，然后下面新建一个 modulesA 在里面写点啥，然后导出去 // A 模块export const modulesA = { state: { username: 'zs' }}再 index.js 中导入 modulesA import {createStore} from 'vuex'import {modulesA} from './modules/modulesA'export default createStore({ modules: { modulesA, }})接着就可以开始使用了 &lt;template&gt; &lt;div class=\"container\"&gt; // 使用 A 模块的 state 数据 &lt;p&gt;{ this.$store.state.modulesA.username }&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;# 开启命名空间 可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名 import {createStore} from 'vuex'import {modulesA} from './modules/modulesA'const modulesB = { namespaced: true, state: { username: '木子曰天' }}export default createStore({ modules: { modulesA, modulesB, }})使用方式","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"待办事项","slug":"待办事项","date":"2022-05-17T05:32:01.000Z","updated":"2022-05-18T05:14:59.422Z","comments":true,"path":"2022/05/17/待办事项/","link":"","permalink":"http://mrnobody233.github.io/2022/05/17/%E5%BE%85%E5%8A%9E%E4%BA%8B%E9%A1%B9/","excerpt":"","text":"# 待办事项 上一次写代码还是上一次，反正已经间隔了许多时间，为了不让自己彻底沦陷娱乐中，所以下定决心来把自己备忘录快要积灰的待办事项给完成，但不能给自己的目标定的那么高，所以将要分批完成，并且将文章置顶，这样也许就能唤醒我想要学习滴动力。 看完《一九八四》 ，整书 358 页，已看完 119 页。 完成黑马程序员 - 小兔鲜儿 06 - 项目架构 复习 vue3 1.vuex 基础和 modules，vuex 持久化。 2.axios 封装 # 已完成","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"待办","slug":"待办","permalink":"http://mrnobody233.github.io/tags/%E5%BE%85%E5%8A%9E/"}]},{"title":"axios封装","slug":"axios封装","date":"2022-05-11T05:29:38.000Z","updated":"2022-05-17T06:05:23.107Z","comments":true,"path":"2022/05/11/axios封装/","link":"","permalink":"http://mrnobody233.github.io/2022/05/11/axios%E5%B0%81%E8%A3%85/","excerpt":"","text":"安装axios npm i axios新建 \" src/utils/request.js \"模块，代码如下 // 3.1 剥离无效数据 3.2 处理 token 失效// 4. 导出一个函数，调用当前的 axios 实例发请求，返回值 promise// 导入 axiosimport axios from 'axios'// 导入 vuex 仓库import store from '@/store'// 导入路由import router from '@/router'// 导出 baseURL, 原因：其他地方不是通过 axios 发请求的地方用上基准地址export const baseURL = '地址'// 1. 创建一个新的 axios 实例const instance = axios.create({ //axios 的一些配置，baseURL timeout baseUrl, timeout:5000})// 2. 请求拦截器，如果有 token 进行头部携带instance.interceptors.request.use(()=&gt;{ // 拦截业务逻辑 // 进行请求配置的修改 // 如果本地有 token 就在头部携带 // 2.1 获取用户信息对象 const { profile } = store.state.user // 2.2 判断是否有 token if (profile.token) { // 2.3 设置 token config.headers.Authorization = `Bearer ${profile.token}` }},(err)=&gt;{ // 将错误对象传递进去 return Promise.reject(err)})// 3 响应拦截器：// 3.1 剥离无效数据：res=&gt;res.data 取出 data 数据，将来调用接口的时候直接拿到的就是后台的数据instance.interceptors.response.use(res=&gt;res.data,(err)=&gt;{ // 401 状态码，进入该函数 // 3.2 处理无效 token if(err.response &amp;&amp; err.response.status === 401){ // 3.2.1 清空无效用户信息 store.commit('user/setUser',{}) // 3.2.2 跳转到登录页面 router.push('/login') // 3.2.3 跳转需要传参 (当前路由地址) 给登录码 const fullPath = encodeURIComponent(router.currentRoute.value.fullPath) //encodeURIComponent 转换 uri 编码，防止解析地址出问题 router.push('/login?redirectUrl=' + fullPath) } return Promise.reject(err)})// 请求工具函数export default (url, method, submitData) =&gt; { // 负责发请求：请求地址，请求方式，提交的数据 return instance({ url, method, // 1. 如果是 get 请求 需要使用 params 来传递 submitData ?a=10&amp;c=10 // 2. 如果不是 get 请求 需要使用 data 来传递 submitData 请求体传参 // [] 设置一个动态的 key, 写 js 表达式，js 表达式的执行结果当作 KEY //method 参数：get,Get,GET 转换成小写再来判断 // 在对象，['params']:submitData ===== params:submitData 这样理解 [method.toLowerCase() === 'get' ? 'params' : 'data']: submitData })}","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Ajax","slug":"Ajax","permalink":"http://mrnobody233.github.io/tags/Ajax/"}]},{"title":"网站设计大赛","slug":"网站设计大赛","date":"2022-05-10T01:45:34.000Z","updated":"2022-05-26T09:11:48.351Z","comments":true,"path":"2022/05/10/网站设计大赛/","link":"","permalink":"http://mrnobody233.github.io/2022/05/10/%E7%BD%91%E7%AB%99%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/","excerpt":"","text":"# 时间 现在已经 2022 年 5 月 10 日 09:57:02 了，提交作品是 20 号，虽然网页早已完成，但是 PPT 还没有动，所以这篇博客主要就来思考一下 PPT 要写什么，如何去介绍这个网页，这个网页用到了什么技术，为什么要做这个网页，围绕这几点，看看能不能想出一大堆文字，这样我滴任务就完成了。 询问了老师的意见，PPT 的作用就是用来介绍网页和队友的，所以使用博客来介绍网页性质是一样的，因为我的审美实在是太差啦，所以我还是使用博客来讲解此网页吧，毕竟我的话比较多，如果做 ppt，文字太多实际上是非常不美观的。 # 起因 我来蓝色技术工作室已经三个学期了，即使当上了团支书，也没有为这里做过什么很有意义的事情，能参加的比赛也是少之又少，拿不出什么成绩，感觉这个社团要凉凉了，但是硬件那边能参加的比赛很多，所以一直支撑这我们，为了这个社团，软件这里也需要多参加活动，保持活跃度，让大家都认识到这里是干什么滴，就这样想着开始从零开始，先参加学院的比赛打磨自己，就有了这个网页，其实还有很多滴原因。 比如软件这边展示的东西很少，也就是没有，大部分同学都是后端，只能写一写接口，这样怎么能拿出去展示，机械就不一样了，能做出许多好玩的东东，航模，智能车，3D 打印。相比软件，唯一能展示的只有网页了，所以刚学完 vue 的我准备自己写一个小小小的项目来巩固一下自己的知识，就想出了这个宣传网站，这样纳新的时候也许就可以展示这个拉夸的网页，让大家都清楚这个社团是干什么的，能为自己带来什么，这也许就是为什么诞生了这个拉夸的网页的原因～～ 其实真正的原因就是… 胃痛患者参加了上学期学院的移动开发设计拿了二等奖领了一个雷蛇鼠标，我也想要！！！这才是主要原因，但是我总不能说我是想要鼠标和键盘才来参加比赛的吧，所以我只能说是，因为软件队能展示的东西只有网页，不然宣传社团的时候东西全是硬件队，软件队就会毫无存在感，好像两个都很重要，所以为了这些，我才有动力去完成这个网页，虽然没花几天，实际上我一两天就可以完成，毕竟功能不多，设计拉夸，毫无美感，但依旧是我的First Vue Web # PPT 讲了许多没用的废话，现在可以开始思考一下如何去介绍网页了，为了不浪费大家的时间来看这个拉夸的网页，所以我准备 PPT 和网页以及代码同时讲，能讲的东西不算多，所以放在一起更好。 # SPA 单页面应用程序 开始之前肯定要介绍一下 SPA 单页面应用程序 然后演示一下 SPA 与其他网页的区别 什么是单页面应用程序 单页面应用程序 （英文名:Single Page Application）简称 SPA，指的就是一个 Web 网站中只有唯一一个 HTML 页面，所有的功能和交互都在这唯一的一个页面内完成 单页面应用程序的特点 单页面应用程序将所有的功能局限于一个 web 页面中。仅在该 web 页面初始化时加载相应的资源（HTML，JavaScript，CSS） 一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转。而是利用 JavaScript 动态的变换 HTML 内容，从而实现用户的交互。 单页应用程序的优点 良好的交互体验 单页面应用的内容的改变不需要重新加载整个页面 获取数据也是通过 Ajax 异步获取 没有页面之间的跳转，所以不会出现 “白屏现象” 良好的前后端工作分离模式 后端专注于提供 API 接口，更容易实现 API 接口的附庸 前端专注于页面的渲染，更利于前端工程化的发展 减轻服务器的压力 服务器只需提供数据，不负责页面的合成与逻辑的处理，吞吐能力会提高几倍。 单页应用程序的缺点 首屏加载慢 不利于 SEO 文字太多懒得看，用几句话总结就是：SPA 非常好用，所有的功能和交互都在这唯一的一个页面内完成，跳转到其他页面不会刷新，但不管什么东西都是有缺点的，如果页面较大，那么开始加载网页的时候就会比较慢，即使是这样也可以通过懒加载来解决这个问题，也就是需要的时候加载，不需要的时候不加载。 # 组件库 作品使用了这两个组件库，有了这两个组件库给我带来了许多的帮助，所以为什么说两天就能做好了， Vant 轻量、可靠的移动端 Vue 组件库 Element Ui 一套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌面端组件库 # 首页 刚进入页面的时候可以看到 Element Ui 中的对话框，提示同学疫情注意安全和配合学校工作。 使用了 Vant 组件中的 NavBar 导航栏，Swipe 轮播。 其中在 NavBar 导航栏中，使用作用域插槽把蓝色技术工作室的图标嵌入进去，并加了一个点击事件，也就是返回上一级。 即使是有组件库也无法满足，所以封装了一个活动组件，由于宣传页面不需要过多的数据，所以模拟后台发送 ajax 数据 通过 v-for 来循环渲染和传参。 点击卡片后可以跳转到相对应的页面。 ✔️伪数据 ActivityList: [ { img: 'https://i.ibb.co/v3CPzDj/Active-img-01.jpg', font_title: '江西科技学院第四届轮式机器人竞速', font_content: '为了加强我校大学生软硬件知识学习，提高实际运算能力，蓝色技术开始进行江西科技学院第四届轮式机器人竞速赛，比赛于2021年11月29日在J8-101举行', type_font: '竞赛', time: '2021.12.13' }, { img: 'https://i.ibb.co/4gJTyf0/1.jpg', font_title: '蓝色技术工作室冬至饺子宴', font_content: '时遇冬至，新加入工作室的小伙伴们已经开始融入这个集体，为了给大伙在忙碌之余增添些色彩，蓝色技术工作室特举办了一场盛大的饺子宴', type_font: '活动', time: '2021.12.22' }, { img: 'https://www.weihaisheng.com/wp-content/uploads/2021/12/2021-768x512.jpg', font_title: '蓝色技术工作室年度总结', font_content: '新年的到来是对过往的检讨对未来的期望,2021已去对过去的一年,总要有句结束语跟着零碎的图片共同回忆惆怅的2021', type_font: '总结', time: '2022.1.1' }, ]✔️v-for 循环渲染与传参 &lt;Activity v-for=\"(item,index) in ActivityList\" :key=\"index\" :time=\"item.time\" :active_img=\"item.img\" :font_title=\"item.font_title\" :font_content=\"item.font_content\" :active_type=\"item.type_font\" @click.native=\"Hop_routing(index)\"&gt;&lt;/Activity&gt;# 活动页 点击左上角的图标即可返回上一个页面 this.$router.go(-1); 当然，在右上角的菜单中也有返回上一级的按钮，使用了 Vant 和 Element Ui 中的抽屉和单元格 # robot 只有这个页面使用了 ajax 来请求数据 使用 v-model 与 input 表单相互绑定，然后绑定按钮，点击触发后发送 ajax 数据，并渲染页面 // 发送 async send() { if (this.ipt_text.trim() === '') { this.ipt_text = '' return Toast.fail('输入内容为空'); return } let text = this.ipt_text $(\".talk_list\").append(` &lt;li class=\"right_word\"&gt; &lt;img style=\"width: 40px;height: 40px;border-radius: 50%\" src=\"data:image/png;base64,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\" /&gt; &lt;span&gt;${text}&lt;/span&gt; &lt;/li&gt;`); this.ipt_text = '' this.myList = text; const {data: res} = await axios.get('http://www.liulongbin.top:3006/api/robot', { params: {spoken: text} }) // 清除 输入框内容 let robot = res.data.info.text; $(\".talk_list\").append(` &lt;li class=\"left_word\"&gt; &lt;img style=\"width: 40px;height: 40px;border-radius: 50%\" src=\"https://jxut-bst.github.io/uploads/avatar.png\" /&gt; &lt;span&gt;${robot}&lt;/span&gt; &lt;/li&gt;`); // console.log(res) },考虑到 PC 端，按下回车键也可以触发按钮 如果技术扎实，完全可以把对话框封装成组件来使用，但是使用了 jquery 来渲染页面 $(\".talk_list\").append(` &lt;li class=\"left_word\"&gt; &lt;img style=\"width: 40px;height: 40px;border-radius: 50%\" src=\"https://jxut-bst.github.io/uploads/avatar.png\" /&gt; &lt;span&gt;${robot}&lt;/span&gt; &lt;/li&gt;`);# 好队友 队员 性别 班级 所做的事 李昊 男 20 专软件 4 班 页面布局与样式，编写博客介绍此网页 于佳琦 女 20 本计算机 5 班 提供相关图片，编写文案，提供样式建议 宁楠 男 21 专软件 5 班 提供伪后台代码与机器人接口 感谢老师们的倾听","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"网站","slug":"网站","permalink":"http://mrnobody233.github.io/tags/%E7%BD%91%E7%AB%99/"}]},{"title":"新的主题:shoka","slug":"新的主题-shoka","date":"2022-05-08T06:26:46.000Z","updated":"2022-05-11T06:14:24.445Z","comments":true,"path":"2022/05/08/新的主题-shoka/","link":"","permalink":"http://mrnobody233.github.io/2022/05/08/%E6%96%B0%E7%9A%84%E4%B8%BB%E9%A2%98-shoka/","excerpt":"","text":"# shoka 太符合我的 xp 了这个主题，虽然配置的过程非常艰苦，特别是搜索功能，但是终于成功一些，还有好多功能没有实现。和之前 Diaspora 这个主题相处的很愉快，虽然也很简洁漂亮，不过让我彻底换成 shoka 的原因是 Diaspora 的主体样式失效了，为什么会失效，嘿嘿嘿，因为我就想看看 shoka 难不难配置，搞了乱七八糟的东西以后最终乱套了，所以我不得不换这个主题，实在是太香了，我会记住你的！嘿嘿嘿 还需要先学习一下这个主题的小语法，实在是太好看啦！！ 点我去 copy","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"网站","slug":"网站","permalink":"http://mrnobody233.github.io/tags/%E7%BD%91%E7%AB%99/"},{"name":"工具","slug":"工具","permalink":"http://mrnobody233.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Vue3-常用CompositionAPi","slug":"Vue3-常用CompositionAPi","date":"2022-05-03T13:38:41.000Z","updated":"2022-05-13T03:34:20.946Z","comments":true,"path":"2022/05/03/Vue3-常用CompositionAPi/","link":"","permalink":"http://mrnobody233.github.io/2022/05/03/Vue3-%E5%B8%B8%E7%94%A8CompositionAPi/","excerpt":"","text":"# setup vue3 中的一个新的配置项，值为一个函数 组件中所用到的：数据，方法等等，均要配置在 setup 中 setup 函数的两种返回值： 若返回一个对象，则对象中的属性，方法，在模板中均可以直接使用。 若返回一个渲染函数：则可以自定义渲染内容 # ref 函数 作用：定义一个响应式的数据 语法: const name = ref('zs') 创建一个包含响应式数据的引用对象（reference 对象 简称 ref 对象） js 中操作数据： name.value 模板中读取数据： 不需要.value, 直接 &lt;div&gt;{{ name }}&lt;/div&gt; &lt;template&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;姓名：{ name }&lt;/h1&gt; &lt;h1&gt;年龄：{ age }&lt;/h1&gt; &lt;h1&gt;工作种类：{ job.type }&lt;/h1&gt; &lt;h1&gt;工资：{ job.money }&lt;/h1&gt; &lt;button @click=\"changeInfo\"&gt;修改人的信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 导入 refimport {ref} from 'vue'export default { name: \"App\", setup() { let name = ref('zs') let age = ref(18) let job = ref({ type: '前端', money: 3000 }) function changeInfo() { name.value = 'ls' age.value = 48 job.value.type = '后端' job.value.money = 4000 console.log(name, age) } return { name, age, changeInfo, job } }}&lt;/script&gt;# reactive 函数 作用：定义一个对象类型的响应数据 (基本类型不要用它，要用 ref 函数) 语法： const person = reactive({ name:'zs', age:18 }) , 接收一个对象 (或者数组) 返回一个代理对象 (proxy 对象) reactive 定义的响应式数据是 “深层次的” 内部基于 ES6 的 Proxy 实现，通过代理对象操作对象内部数据进行操作 &lt;template&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;姓名：{ person.name }&lt;/h1&gt; &lt;h1&gt;年龄：{ person.age }&lt;/h1&gt; &lt;h1&gt;工作种类：{ person.job.type }&lt;/h1&gt; &lt;h1&gt;工资：{ person.job.money }&lt;/h1&gt; &lt;h1&gt;爱好：{ person.hobby }&lt;/h1&gt; &lt;button @click=\"changeInfo\"&gt;修改人的信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import {reactive} from 'vue'export default { name: \"App\", setup() { // 数据 let person = reactive({ name: 'zs', age: 18, job: { type: '前端', money: 3000 }, hobby: ['抽烟', '喝酒', '烫头'] }) // 方法 function changeInfo() { person.age = 48 person.job.type = '后端' person.job.money = 4000 person.hobby[0] = '放屁' console.log(person.name, person.job.type) } return { person, changeInfo, } }}&lt;/script&gt;# reactive 对比 ref 从定义数据角度对比： ref 用来定义： 基本类型数据 reactive 用来定义 对象 (或数组) 类型数据 备注： ref 也可以用来定义对象 (或数组) 类型数据，它内部会通过 reactive 转为代理对象 从使用角度对比 ref 定义数据：操作数据需要 .value , 读取数据时模板中直接读取，不需要 .value reactive 定义数据：操作数据与读取数据：均不需要 .value # 计算属性与监视 # 1.computed 函数 与 Vue2 中 computed 配置功能一致 写法 &lt;template&gt; 姓：&lt;input type=\"text\" name=\"\" id=\"\" v-model=\"person.firstName\"&gt; &lt;br&gt; 名：&lt;input type=\"text\" name=\"\" v-model=\"person.lastName\"&gt; &lt;br&gt; &lt;span&gt;全名：{ person.fullName }&lt;/span&gt; &lt;br&gt; 全名：&lt;input type=\"text\" v-model=\"person.fullName\"&gt;&lt;/template&gt;&lt;script&gt;import {reactive, computed} from \"vue\";export default { name: \"App\", setup() { // 数据 let person = reactive({ firstName: \"张\", lastName: \"三\" }) // 计算属性 -- 简写形式 (没有考虑计算属性被修改的情况) /* person.fullName = computed(() =&gt; { return person.firstName + \"-\" + person.lastName }) */ // 计算属性 -- 完整写法 (考虑读和写) person.fullName = computed({ get() { return person.firstName + \"-\" + person.lastName }, set(value) { const nameArr = value.split('-') person.firstName = nameArr[0] person.lastName = nameArr[1] } }) return { person, } }}&lt;/script&gt;# watch 函数 与 Vue2 watch 配置功能一致 &lt;template&gt; &lt;h2&gt;当前求和为：{ sum }&lt;/h2&gt; &lt;button @click='sum++'&gt;+1&lt;/button&gt; &lt;hr&gt; &lt;h2&gt; 当前的信息为：{ msg }&lt;/h2&gt; &lt;button @click=\"msg+='!'\"&gt;修改信息&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import {ref, watch} from \"vue\";export default { name: \"App\", setup() { // 数据 let sum = ref(0) let msg = ref('你好吗') // 情况 1： 监视 ref 所定义的一个响应式数据 /* watch (sum, (newValue, oldValue) =&gt; { console.log ('sum 变了 ', newValue, oldValue) }, {immediate: true, deep: true}) */ // 情况 2： 监视 ref 所定义的多个响应式数据 watch([sum, msg], (newValue, oldValue) =&gt; { console.log('sum 或 msg 变了', newValue, oldValue) }, {immediate: true, deep: true}) return { sum, msg } }}&lt;/script&gt;# watchEffect 函数 不用指明监视哪个属性，监视的回调中用到哪个属性，就监视哪个属性 类似 computed： computed 注重计算出的值（回调函数的返回值），所以必须要写返回值 watchEffect 更注重的是过程 （回调函数的函数体），所以不用写返回值 //watchEffect 所指定的回调中用到的数据只要发生变化，就会直接重新执行回调import { watchEffect } from 'vue'watch(()=&gt;{ const x1 = sum.value console.log('watchEffect配置的回调执行了')})# 通过 ref 获取 DOM 元素","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"浅度睡眠","slug":"浅度睡眠","date":"2022-04-25T15:16:45.000Z","updated":"2022-04-26T02:03:08.481Z","comments":true,"path":"2022/04/25/浅度睡眠/","link":"","permalink":"http://mrnobody233.github.io/2022/04/25/%E6%B5%85%E5%BA%A6%E7%9D%A1%E7%9C%A0/","excerpt":"","text":"# 羽毛球 昨天下午和ButterflyFish，废宅充电器，胃病患者，还有果果超甜以及他的室友一起去打室内羽毛球，虽然平均每人六块钱，实际上体验还是非常不错的，就是没有空调。我和ButterflyFish一组，一开始对战的是果果超甜和他的室友，胃病患者则是和充电器一组。太久没有运动果然非常吃力，由于ButterflyFish的运动细胞实在是太差了，加上她并不会打羽毛球，所以相当于是我一个人打他们两个人，本来是不打算带ButterflyFish一起打的，这样他们就不会认真打，考虑到有个萌新就会有所限制，还好差一个人，果然一起打球还是很开心的，等有时间了天气好了我一定好好教她怎么发球和接球。 虽然ButterflyFish并不会打球，好在我技高一筹，我滴发球实在是太变态了，打的非常阴间，靠着发球得分我和ButterflyFish击败了他们两个，接下来是胃病患者和充电器，因为我的体力不支，很快便败下阵来。实在是太虚了！！还没几下就不行了，不过这也不能完全怪我（试图安慰自己），连续好几早上六点起来做核酸八点钟又要上课，因为睡眠不足才导致的体力下降，就是酱紫！要不是因为没蓝了，不然我就开始暴打胃病患者，脚踢废宅充电器。结束之后我和果果超甜一起回他宿舍洗澡，因为我寝室的热水器坏了呜呜呜，厕所有灯的感觉真滴太好了，不知道我们寝室什么时候会把热水器修好。 # 浅度睡眠 因为太累了所以今天的睡眠质量非常高，能感觉到浑身充满了力量，已经很久没有这么有精神过了，所以我做完核酸后睡到十点半就去工作室了，哈哈哈哈。我的睡眠质量实在是太垃圾啦，基本上每天都是浅睡，关于为什么这样其实我心里还是有点 b 数的，首先是手机，玩着玩着就忘记了时间，接着是睡眠环境，只要有一点风吹草动我就睡不着，更何况寝室还有一个打呼噜的室友，最重要的是胡思乱想，哪来那么多东西给我想，每天都要睡觉，每天都要胡思乱想。上到国家政治大事，下到身边琐事。我想的东西跨度有点大，打个比方吧。 比如我想着学校解封以后去吃牛蛙，然后联想到疫情，接着联想到国家如何防控疫情，然后是国外想要与新冠病毒共存，只要它一直共存，我们这里就永远不会清零，奶奶滴，实在是太可恶了。我玩瘟疫公司都打不过人类，他们实在是太团结了，只要有一个国家做好解药就会用飞机运送到各个国家，相互帮助。然而现实是不一样，游戏中国家没有勾心斗角，现实会有，然后联想到这个 sb 游戏在一些版本中把我们国家地图缺少一部分，少了台湾和香港，并且把蒙古国给合并在中国。然后思维跳跃，直接回到幼儿园，回想起我妈妈给我做炸香蕉吃，太好吃了，用面粉包裹，然后粘上白糖，人间美味啊，然后是小学大晚上和我堂妹跑到隔壁财经大学看别人放孔明灯，结果玩太晚了回去被我婶婶给骂了，骂了以后给我和堂妹一人一瓶泡在热水里的旺仔牛奶，可是太久了已经变温了，骂的我和我堂妹畏畏缩缩的去睡觉了。又跳回到现在，原来我上了大学才知道家附近的财经大学是一本，小时候可以随便进出，长大了却进不去，呜呜呜，马上就要大三了，结果专升本还是得考本校，而且还可能考不上，那我考不上可以提前去打工吗，这样我就可以提前赚小钱，本来暑假可以去舅舅公司实习的，可是疫情又严重了被困在学校里快逼疯了。大部分学校的学生居然因为疫情不能出校而通过跳广场舞来解闷，那学校里面有疫情怎么办，只是有时候会看到保安骑着电动车叫没有戴口罩的学生带好口罩而已，看到保安我又想起上学期纳新的时候我们社团的帐篷被别人偷走了，然后去保卫处调监控，写笔录，我和胃病患者一起去的，结果是那一条路居然没有监控，我真滴服了，因为没有监控他们也懒得帮我们找，后来才看见被某社团替换了他们坏掉的帐篷，丢在了后面，真滴太恶心了。 就是这样每天胡思乱想，从一件事联想到另一件事，没完没了才导致我的体质降低，影响我的学习，健康，寿命，通过昨天打羽毛球我才发现好像并不是我睡不着，而是我不够累，看来我得每天和果果超甜一起去跑跑步，这样我就可以睡好觉了，也许吧，，，想我这样的人应该去写小说，可惜我的文笔实在是太垃了，写博客用的都是大白话。得多去看看书，不然人家用高级语言骂我都不知道，正好我被充电器推荐买了《一九八四》《我们》《美丽新世界》，因为是上海的出版社，所以我付款后到现在还没有发货，这些好像都不是问题，因为ButterflyFish的《仿生人会梦见电子羊吗？》我还没有看完，这就是我唯一担心的问题，我能不能静下心来把一本书看完，实际上是可以的，在 20 年的暑假我看完了《麦田里的守望者》所以我相信我还是能够把那些书看完滴，嘿嘿，就这样吧平板打字太累了，掰掰。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"},{"name":"周记","slug":"周记","permalink":"http://mrnobody233.github.io/tags/%E5%91%A8%E8%AE%B0/"}]},{"title":"axios拦截器","slug":"axios拦截器","date":"2022-04-24T12:45:28.000Z","updated":"2022-04-24T13:46:58.136Z","comments":true,"path":"2022/04/24/axios拦截器/","link":"","permalink":"http://mrnobody233.github.io/2022/04/24/axios%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"# 拦截器 拦截器 (英文：interceptors) 会在每次发起 ajax 请求 和得到响应 的时候自动被触发 应用场景： Token 身份认证 Loading 效果 etc… # 配置请求拦截器 通过 axios.interceptors.request .use( 成功的回调，失败的回调) 可以配置请求拦截器，其中失败的回调函数可以被省略！ axios.interceptors.request.use((config)=&gt;{ // 一定要 return config 固定写法 return config; },(error)=&gt;{ return Promise.reject(error); })# 请求拦截器 -Token 认证 // 1. 导入 axiosimport axios from \"axios\";// 2. 设置请求的根路径axios.defaults.baseURL = 'http://127.0.0.1:8888/api/private/v1/'// 配置请求拦截器axios.interceptors.request.use(config =&gt; { // 为当前请求配置 Token 认证字段 config.headers.Authorzation = 'bear xxx' console.log(config) return config})// 3. 把包挂载到 vue 的原型对象上Vue.prototype.$http = axios# 展示 Loading 效果 借助 element ui 提供的 Loading 效果组件 可以方便的实现 Loading 效果展示 // 1. 按需导入 Loading 效果组件import { Loading } from 'element-ui'// 2. 声明变量，用来存储 Loading 组件的实例对象let loadingInstance = null// 配置请求拦截器axios.interceptors.request.use(config =&gt; { // 调用 Loading 组件的 service () 方法，创建 Loading 组件的实例，并全屏展示 loading 效果 loadingInstance = Loading.service({fullscreen: true}) return config})# 配置响应拦截器 通过 axios.interceptors.response .use( 成功的回调，失败的回调) 可以配置响应拦截器，失败的回调函数依旧可以被省略。 axios.interceptors.response.use((response)=&gt;{ return response; },(error)=&gt;{ return Promise.reject(error); })# 响应拦截器 - 关闭 Loading 效果 调用 Loading 实例提供的 close () 方法即可关闭 Loading 效果 // 配置响应拦截器axios.interceptors.response.use(response =&gt; { // 关闭 loading loadingInstance.close() return response})","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Ajax","slug":"Ajax","permalink":"http://mrnobody233.github.io/tags/Ajax/"}]},{"title":"第一次拆机","slug":"第一次拆机","date":"2022-04-23T15:30:17.000Z","updated":"2022-04-23T16:15:44.480Z","comments":true,"path":"2022/04/23/第一次拆机/","link":"","permalink":"http://mrnobody233.github.io/2022/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8B%86%E6%9C%BA/","excerpt":"","text":"# 周记 创建了一个新的标签 叫做周记 和日记差不多，不过是换成了一周一次，又或者是好几周一次，所以取名为周记， # 起因 昨天充电器把apex传给我了，安装好以后确实能玩，把所有配置降到最低以后还是卡的一批，充电器检查后找到了一些原因，就是我的电脑太辣鸡啦，除了写代码一无是处，还有一些原因是我的电脑买了快两年了，散热器积灰了，风都出不来了，从而导致的帧数降低，为了让我更好的使用这台 华为 matebook13 2020 办公本，来玩 apex 和 CSGO 带充电器 上大分，他今天中午带了螺丝刀准备帮我拆机清理灰尘，说实话我还是非常担心的。 # 回忆 在 19 年的时候我也尝试过自己拆机，不过拆的是我的手机，我心爱的 小米 mix2s 因为它打游戏的续航能力实在是太垃圾了啦，玩两局吃鸡就基本没电了，所以我买了它的 4500 毫安的电池，准备给它换一个新的心脏。经历了九九八十一难，我终于把它的后盖打开了，一切都准备就绪，可是我弄错了一根线，以为它是电源线，实际上它是前置摄像头的线，用力一拔下后，断了。。。当时我心都凉了一大截，在一瞬间我买什么手机都想好了，后来长按开机后才发现是前置摄像头，吓屎我了，差点就要换手机了。嘿嘿，虽然不能拍我的美照了，但是游戏续航提升了一大截，缺点就是充电慢了许多。 # 拆机 经历了那件事后，我对拆机有了一些莫名的恐惧感，生怕拆断一根线，但是现在是充电器来帮我拆，即使是这样我还是会非常担心滴，毕竟我没有更多的钱买新的电脑了。在拆完外面六个螺丝之后，准备打开后盖，我差点要暴力拆开后壳了，还好充电器叫我看一下拆机视频，结果发现垫子底下居然藏了四个螺丝，妈的差点外壳就要报废了。所以需要回到我宿舍使用吹风机把垫子里面的胶吹化掉然后拿下来。回宿舍期间我给充电器买了个 1.5￥ 的冰棒作为报酬。拆完垫子之后回到工作室，终于看到了我心爱的电脑的内脏，长这样子。 可见灰尘还是蛮多的，接下来就看充电器的操作了，不愧是老手，在拆机之前居然双手摸桌子下的铁柱子，来释放人体电流，防止电脑触电烧机，实在是太高级了！在他的努力下，我的电脑居然安然无恙，正常开机了，而且还抹了散热硅胶，本来想 狠狠敲诈 好好报答他的，没有机会了 嘿嘿。 # 结尾 后面就是打开apex测试了一下，太棒了，稳定 40 帧，偶尔上 60，俗话说：1 帧能玩 2 帧流畅 3 帧电竞, 我的宝贝本子居然上 40 帧，简直就是神机啊。测试了几局以后还开出了两个金箱子，紫箱子，不愧是宝藏本子，还给我带来好运，真滴太棒啦，唯一的缺点就是风扇声更大了，仿佛回到了我和它刚见面的模样，当时它也是转的很大声，经历了这一次拆机过程以后，我学会啦！！ 就是不要自己拆机，买个冰棒给充电器让他帮我拆就行了 就这样，掰掰！期待夏天买新散热硅脂再次拆机.","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"周记","slug":"周记","permalink":"http://mrnobody233.github.io/tags/%E5%91%A8%E8%AE%B0/"}]},{"title":"flex布局","slug":"flex布局","date":"2022-04-23T08:18:52.000Z","updated":"2022-04-23T15:24:03.911Z","comments":true,"path":"2022/04/23/flex布局/","link":"","permalink":"http://mrnobody233.github.io/2022/04/23/flex%E5%B8%83%E5%B1%80/","excerpt":"","text":"# flex 布局原理 flex 是 flexible Box 的缩写，意为 “弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。 当我们为父盒子设为 flex 布局以后，子元素的 float,cleat和vertical-align属性将失效。 伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 = flex 布局 总结来说就是通过给父盒子添加 flex 属性，来控制子盒子的位置和排序方式 # 常见父项属性 以下有 6 个属性是对父元素设置的 flex-direction: 设置主轴的方向 justify-content: 设置主轴上的子元素排序方式 flex-wrap: 设置子元素是否换行 align-content: 设置侧轴的子元素的排序方式 (多行) align-items: 设置侧轴上的子元素排序方式 (单行) flex-flow: 复合属性，相当于同时设置了 flex-direction 和 flex-warp # flex-direction 设置主轴的方向 # 主轴与侧轴 在 flex 布局中，是分为主轴和侧轴两个方向的，同样的叫法有：行和列，x 轴 和 y 轴 默认主轴方向就是 x 轴方向，水平向右 默认侧轴是方向是 y 轴方向，水平向下 # 属性值 flex-direction 属性决定主轴的方向 (即项目的排列方向) 注意：主轴的侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴，而子元素是跟着主轴来排序的 属性值 说明 row 默认值从左到右 row-reverse 从右到左边 column 从上到下 column-reverse 从下到上 # justify-content 设置主轴上的子元素排列方式 justify-content 属性定义了项目在主轴上的对齐方式 注意：使用这个属性之前一定要确定好主轴是哪个 属性值 说明 flex-start 默认值 从头部开始 如果主轴是 x 轴，则从左到啊啊有 flex-end 从尾部开始排列 center 在主轴居中对齐 (如果主轴是 x 轴则水平居中) space-around 平均剩余空间 space-between 先两边贴边 再平分剩余空间 # flex-wrap 设置子元素是否换行 默认情况下，项目都排在一条线上 (又称 “轴线”)，flex-wrap 属性定义，flex 布局中默认是不换行的。 属性值 说明 nowrap 默认值，不换行 wrap 换行 # align-items 设置侧轴上的子元素排序方式 (单行) 属性值 说明 flex-start 默认值 从上到下 flex-end 从下到上 center 挤在一起居中 (垂直居中) stretch 拉伸 # align-content 设置侧轴上的子元素排序方式 (多行) 设置子项在侧轴上的排列方式并且只能用于子项出现 换行，在单行下是没有效果的 属性值 说明 flex-start 默认值在侧轴的头部开始排列 flex-end 在侧轴的尾部开始排列 space-around 子项在侧轴平分剩余空间 space-between 子项在侧轴先分布在两头，在平分剩余空间 stretch 设置子项元素高度平分父元素高度 stretch 设置子项元素高度平分元素高度 # flex-flow flex-flows 是 flex-direction 和 flex-wrap 的复合属性 # 常见子属性 flex 子项目占的份数 align-self 控制子项自己在侧轴的排列方式 order 属性自定义子项的排列顺序 # flex 属性 flex 属性定义子项目分配剩余空间，用 flex 来表示占多少份数 .box{ flex:1;}# align-self 控制子项自己在侧轴的排列方式 align-self 属性允许单个项目与其他项目不一样的对齐方式，可覆盖 align-item 属性 默认值为 auto ，表示继承父元素的 align-items 属性 ，如果没有父元素，则等同于 stretch .big :nth-child(1) { align-self: center; }# order 属性定义项目的排列顺序 数值越小 排列越靠前 默认为 0 与 z-index 不同 # 复习 经典学了忘记，现在写博客里就可以看看啦，要不是 充电器 说要卷我 我可能要很久才会 复习 flex 布局 0.0 为了感谢他 我明天和他打羽毛球要干爆他。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"http://mrnobody233.github.io/tags/CSS/"}]},{"title":"黑马程序员-电商管理知识总结","slug":"黑马程序员-电商管理知识总结","date":"2022-04-21T10:32:51.000Z","updated":"2022-04-26T04:03:33.146Z","comments":true,"path":"2022/04/21/黑马程序员-电商管理知识总结/","link":"","permalink":"http://mrnobody233.github.io/2022/04/21/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-%E7%94%B5%E5%95%86%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"# 使用阿里图标 把下载好的 font 文件放进 assets 目录下 在 main.js 中导入字体图标 import './assets/fonts/iconfont.css' 复制类名即可 &lt;el-input prefix-icon=\"iconfont icon-3702mima\"&gt;&lt;/el-input&gt; iconfont 是固定写法 # vue2 中全局配置 axios 在 main.js 中导入 axios import axios from \"axios\"; 设置请求的根路径 axios.defaults.baseURL = 'http://127.0.0.1:8888/api/private/v1/' 把包挂载到 vue 的原型对象上 Vue.prototype.$http = axios 通过 this 就可以访问原型上的 $http 发起 axios 请求 login() { this.$refs.loginFormRef.validate(async value =&gt; { if (value === false) return; const {data: res} = await this.$http.post('login', this.loginForm) console.log(res) }) } # 登录成功后保存 token 将 token 保存在 sessionStorage 中 window.sessionStorage.setItem('token', res.data.token); 通过编程式导航跳转到主页 this.$router.push('/home') 路由导航守卫控制访问权限 router.beforeEach((to, form, next) =&gt; { if (to.path === '/login') return next() // 获取 token const tokenStr = window.sessionStorage.getItem('token') // 如果 token 是空值，则返回 login 页面 if (!tokenStr) return next('/login') next()}) # 退出登录 清空 token window.sessionStorage.clear() 跳转到登录页面 this.$router.push('/login') # 通过 axios 请求拦截器添加 token //axios 请求拦截axios.interceptors.request.use( config =&gt; { // 为请求头对象，添加 Token 验证的 Authorization config.headers.Authorization = window.sessionStorage.getItem('token') return config} )如果不通过拦截器添加 token 是这样写的～～果然学了拦截器后方便了很多呐 // 获取菜单列表数据 async getMenuList() { this.token = window.sessionStorage.getItem('token') const {data: res} = await this.$http.get('menus', {headers: {'Authorization': this.token}}) console.log(res) }","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"http://mrnobody233.github.io/tags/axios/"}]},{"title":"axios","slug":"axios","date":"2022-04-19T03:09:31.000Z","updated":"2022-04-21T08:13:19.943Z","comments":true,"path":"2022/04/19/axios/","link":"","permalink":"http://mrnobody233.github.io/2022/04/19/axios/","excerpt":"","text":"# axios 是什么东东 Axios 是专注于网络数据请求的库 相比原生的 XMLHttpRequest 对象 ， axios 简单易用 相比 jquery，axios 更加轻量化，只专注于网络数据请求 # axios 发起 GET 请求 axios 发起 get 请求的语法： axios.get('url', { params:{ 参数 } }).then(callback) 具体请求实例如下： // 请求的 URL 地址const url = 'http://www.liulongbin.top:3006/api/get'// 请求的参数对象const paramsObj = {name: 'zs', age: 20}// 调用 axios.get () 发起 GET 请求axios.get(url, {params: paramsObj}).then((res) =&gt; { //res.data 才是服务器返回的数据 let result = res.data console.log(result)}) # axios 发起 POST 请求 axios.post('url',{ 参数 }).then( callback ) 具体请求实例如下： // 请求的 url 地址const postUrl = 'http://www.liulongbin.top:3006/api/post'// 要提交到服务器的数据const dataObj = {location: '北京', address: '顺义'}// 调用 axios.post () 发起 POST 请求axios.post(postUrl, dataObj).then((res) =&gt; {//res.data 才是服务器发送的数据 let result = res.data console.log(result)}) # 直接使用 axios 发起请求 asiox 也提供了类似 jQuery 中 $.ajax () 的函数，语法如下： axios({ method: ' 请求类型 ', url: ' 请求的URL地址 ', data: { post数据 } params: { GET参数 }}).then(callback)# 直接使用 axios 发起 GET 请求 axios({ method: 'GET', url: 'http://www.liulongbin.top:3006/api/get', params: { // GET 参数要通过 params 属性提供 name: 'zs', age: 20 }}).then((res) =&gt; { console.log(res.data)})# 直接使用 axios 发起 POST 请求 axios({ method: 'POST', url: 'http://www.liulongbin.top:3006/api/post', data: { // POST 数据要通过 data 属性提供 location: '北京', address: '顺义' }}).then((res) =&gt; { console.log(res.data)}) # 结合 async 和 await 来使用 axios 调用 axios 之后 可以使用 async/await 进行简化 使用解构赋值，从 axios 封装的大对象中，把 data 属性解构出来 把结构出来的 data 属性，使用 冒号 进行重命名，一般都重命名为 可以使用结构赋值 async btnGet() { const {data: res} = await axios({ method: 'GET', url: 'http://www.liulongbin.top:3006/api/get', params: { // GET 参数要通过 params 属性提供 name: 'zs', age: 20 } }) console.log(res) }","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Ajax","slug":"Ajax","permalink":"http://mrnobody233.github.io/tags/Ajax/"}]},{"title":"凌晨校园","slug":"凌晨校园","date":"2022-04-17T16:06:15.000Z","updated":"2022-04-18T13:31:48.415Z","comments":true,"path":"2022/04/18/凌晨校园/","link":"","permalink":"http://mrnobody233.github.io/2022/04/18/%E5%87%8C%E6%99%A8%E6%A0%A1%E5%9B%AD/","excerpt":"","text":"# 第二次 本来想在工作室过夜写会儿代码的，但是在十一点四十的时候果果超甜突然告诉我明天早上要做核酸，TNND，我真的受不了了，明明今天已经做过了，居然连续做两天，所以我准备回宿舍，不过红绿蓝并不是只有我一个人，还有一个老师也在，整个地方只有他的办公室还是亮着的，为了不让他发现我在这里，我小心的打开自己办公室的门，然后悄咪咪的溜到大门口，这个真的是高难度，因为大门太重了，开的时候会发出嘎吱嘎吱的响声，我也经常在办公室听大门的开关声来判断是否有人进来。所以结局很正常，我被他发现了，关键是我打都没打开门，因为门被锁了，而且还是磁力锁，我来这里三个学期了都没有看到他们打开磁力，今天 TMD 突然就打开了，然后老师就说了一句 谁？ 把我尬死在原地，我故作镇定，回答：还能出去吗？ 然后他说待会走。 然后我就默默的回到自己的办公室打开小灯开始看自己的代码，尬的我连刚刚学的 Vuex 传值都不会了，加上我尿急，我都快绷不住了，过了好一会儿他来了，说 走吧 ，问我为什么这么晚还没回宿舍，我说项目还有一些需要改的地方，他也没多问，出去的时候我才知道，磁力门并不是那个老师弄的，他也尝试拉了一下门，和我一样打不开，我按了一下右边的按钮就开了，接着就在外面等他锁门，拿手电筒照着他，看他锁门，尬死我了，心里想赶紧让我先走吧，然后他就让我先回去了，哎，还好他没问我这么晚了怎么回宿舍，不然我真的答不出来。 宿舍离工作室也不算很远，不过路上还是特别可怕的，第一个是太黑了一点灯都没有，第二个是太冷了，第三个就是妈的那个SB孔雀突然叫了一下，把我吓得鸡皮疙瘩都起来了，搞不明白为什么孔雀要放在我宿舍对面，现在住在这栋宿舍的人每天都在群里想着怎么杀掉这几个孔雀。 终于到了老地方，那颗支撑我回宿舍的小树，看来多锻炼还是特别有用的，对于我来说通过这个树上二楼是一件非常轻松的事情，也许是我太轻了，手臂能够把我支撑起来，就这样我安全都回去了。 # 第一次 实际上这并不是我第一次这么晚还在学校外面溜达，在几号来着。。也就前几天吧，因为一些原因，果果超甜，胃痛患者，还有我很晚的时候在外面溜达，本来想着等老师走了以后再回工作室的，在外面溜达了好一会儿，终于来学校这么久了找到古茗的位置了，还有我去年暑假留校做比赛经常点的外卖的位置，那个炸鸡真的太好吃了，还看见了我们学校的留学生在操场用音响放音乐，如果不是封校了，我们肯定会出去溜达的，真的可惜呀，， 过了好一会我们准备回工作室了，结果发现二楼大门被锁了。。通常是一楼被锁的，我们可以从食堂小门进去，但是二楼被锁了实在就无能为力了。期间尝试了很多方法进去，结果也就我能实现，可以从厕所那里爬过去，也就爬两个小房间的高度，然后抓着钢管到男厕所窗口就可以了，我示范了一遍给他们看，但是到钢管哪里我就没爬了，太黑了，为了安全考虑我和他们一起回宿舍了，还是熟悉的位置，我第一个爬上去了，能感觉到树枝被裁剪了许多，相比之前爬难了一点点点点，但是对于他们来说就特别困难了，努力了半天，他们终于也上来了，看得我心惊胆跳的，真是捏了一把汗，如果失误了从上面摔下来，也就一条腿骨折而已，如果没站稳脑袋磕到石头了也就一辈子躺床上罢了。安全的回到了宿舍，可是 胃痛患者 并不想回自己宿舍，因为和室友关系不好什么的，所以我善心大方收留了他 ，也就是这个决定，让我尬死了一晚上 那个时候太热了，又热又闷的，我想去开空调，但是空调线没插，我想过去插线，可是那边室友已经睡着了，所以结局很明了，我把线插好了，也把室友吵醒了被骂了一顿，可以说是我今年最尬的时候了，那晚过的很煎熬，果然我还是比较适合一个人睡，如果废宅充电器在的话就好了，他可以一晚上不睡，然后让胃痛患者睡他床，不过想想也不可能，因为不知道他们宿舍怎么上二楼，不过我以后再也不会让别人和我一起挤那么小的床睡觉了。拜拜 这次写的太粗略了，很多细节都没有写，可能是这一篇生活写的太多了，而且现在已经 12：48 了，明天还得早起做核酸，，等过几年我突然想起来了更多细节，也许会补充上去吧？也许。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"}]},{"title":"Vuex","slug":"Vuex","date":"2022-04-14T12:22:26.000Z","updated":"2022-04-19T04:30:59.542Z","comments":true,"path":"2022/04/14/Vuex/","link":"","permalink":"http://mrnobody233.github.io/2022/04/14/Vuex/","excerpt":"","text":"# Vuex 概述 # 组件之间共享数据 父向子传值：v-bind 属性绑定 子向父传值：自定义事件 兄弟之间共享数据：EventBus $on 接收数据的那个组件 $emit 发送数据的那个组件 以上传值只适合小范围，如果需要频繁的大范围的共享就可使用 vuex # Vuex 是什么 是实现组件全局状态 (数据) 管理的一种机制，可以方便的实现组件之间数据的共享 使用 Vuex 统一管理状态的好处 能够在 vuex 集中管理共享的数据，易于开发和后期维护 能够高效地实现组件之间的数据共享，提高开发效率 存储在 vuex 中的数据都是响应式的，能够实时保持数据与页面的同步 # Vuex 的基本使用 # 1. 安装 vuex 依赖包 npm i vuex -s # 2. 导入 vuex 包 import Vuex from 'vuex' Vue.use(Vuex) # 3. 创建 store 对象、 const store = new Vuex.store({ //state 中存放的就是全局共享的数据 state:{ count: 0 }})# 4. 将 store 对象挂载到 vue 实例中 new Vue({ el:'#app', render:h=&gt;h(app), router, // 将创建的共享数据，挂载到 Vue 实例中 // 所有的组件，就可以直接从 store 中获取全局的数据了 store}) # vuex 的核心概念 Vuex 中的主要核心概念如下： State Mutation Action Getter # State state 提供位移的公共数据源，所有共享的数据都要统一放到 Store 的 State 中进行存储 // 创建 store 数据源，提供唯一公共数据const store = new Vuex.Store({ state: { count: 0 }})组件访问 State 中数据的 第一种方式： `this.$store.state.全局数据名称组件访问 State 中数据的 第二种方式： // 1. 从 vuex 中按需导入 mapState 函数import { mapState } from 'vuex'通过刚才导入的 mapState 函数，将当前组件需要的全局数据，映射为当前组件的 computed 计算属性 // 2. 将全局数据，映射为当前组件的计算属性computed:{ ...mapStated(['count'])} # Mutation Mutation 用于变更 Store 中的数据。 只能通过 mutation 变更 Store 数据，不可以直接操作 Store 中的数据 通过这种方式虽然操作起来繁琐一些，但是可以集中监控所有数据的变化 // 定义 Mutationconst store = new Vuex.store({ state:{ count: 0 }, mutations: { add(state) { // 变更状态 state.count++ } },})// 触发 mutationmethods: {btnHandler1() { // 触发 mutation 的第一种方式 this.$store.commit('add') }}可以在触发 mutations 时传递参数 mutations: { add(state, step) { // 变更状态 state.count += step } },methods: { btnHandler1() { // 在调用 commit 函数， // 触发 mutations 时携带参数 this.$store.commit('addN', 3) } }this.$store.commit() 是触发 mutations 的第一种方式，触发 mutations 的第二种方式： // 1. 从 vuex 中按需导入 mapMutations 函数 import { mapMutations } from 'vuex'通过刚才导入的 mapMutations 函数 将需要的 mutations 函数 映射为当前组件的 methods 方法： // 2. 将指定的 mutations 函数 映射为当前组件的 methods 函数 methods: { ...mapMutations(['sub', 'subN']), reduction1() { this.sub() }, reduction2() { this.subN(3) } } # Action Action 用于处理异步任务 如果通过异步操作变更数据，必须通过 Action，而不能使用 Mutation，但是在 Action 中还是要通过触发 mutation 的方式间接变更数据。 定义 Action // 只有 mutation 中定义的函数，才有权力修改 state 中的数据 mutations: { add(state) { // 不要在 mutations 函数中 执行异步操作 /* setTimeout(() =&gt; { state.count++ },1000)*/ state.count++ }, }, actions: { addAsync(context) { setTimeout(() =&gt; { // 在 actions 中，不能直接修改 state 中的数据 // 必须通过 context.commit () 触发 某个 mutation 才行 context.commit('add') }, 1000) }触发 Action methods:{ handle(){ // 触发 actions 的第一种方式 this.$store.dispath('addAsync') }}触发 actions 异步任务时携带参数: mutations: { addN(state, step) { // 变更状态 state.count += step },},actions: { addNAsync(context, step) { setTimeout(() =&gt; { context.commit('addN', step) }, 1000) }},btnHandlerWaitN() { this.$store.dispatch('addNAsync', 3)}this.$store.dispath() 是触发 actions 的第一种方式，触发 actions 的 第二种方式： // 1. 从 vuex 中按需导入 mapActions 函数import { mapActions } from 'vuex'通过刚才导入的 mapActions 函数，将需要的 actions 函数，映射为当前组件的 methods 方法： methods:{ ...mapActions(['addAsync','addNsync'])} # Getter Getter 用于对 Store 中的数据进行加工处理形成新的数据。 Getter 可以对 Store 中已有的数据加工处理之后形成新的数据，类似 Vue 的计算属性。 Store 中数据发生变化，Getter 的数据也会跟着变化。 export default new Vuex.Store({ state: { coun使用 getters 的第一种方式 &lt;h3&gt;&lt;!--swig￼0--&gt;&lt;/h3&gt;使用 getters 的第二种方式 &lt;h1&gt;&lt;!--swig￼1--&gt;&lt;/h1&gt;import { mapGetters} from 'vuex' computed: { ...mapGetters(['showNum']) },","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue计算属性-自定义事件-watch监听器","slug":"Vue计算属性-自定义事件-watch监听器","date":"2022-04-10T12:11:01.000Z","updated":"2022-04-13T12:04:21.108Z","comments":true,"path":"2022/04/10/Vue计算属性-自定义事件-watch监听器/","link":"","permalink":"http://mrnobody233.github.io/2022/04/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6-watch%E7%9B%91%E5%90%AC%E5%99%A8/","excerpt":"","text":"# 计算属性 计算属性本质上就是一个function 函数, 它可以实时监听data 中数据的变化，并return 一个计算后的新值，供组件渲染 DOM 时使用 # 声明计算属性 计算属性需要以function 函数的形式声明到组件的computed 节点中，示例代码如下 &lt;input type=\"text\" v-model.number=\"count\"&gt;&lt;p&gt;&lt;!--swig￼0--&gt;乘以 2 的值为：&lt;!--swig￼1--&gt; &lt;/p&gt;&lt;script&gt; export default { data(){ return{ count:1, } }, computed:{ plus(){ // 计算属性，监听 data 中 count 的变化，自动计算出 count * 2 之后的新值 return this.count * 2 } } }&lt;/script&gt;# 计算属性的使用注意点 计算属性必须定义在 computed 节点中 计算属性必须是一个 function 的函数 计算属性必须有 return 返回值！！ 计算属性必须当作普通属性使用 # 计算属性 vs 方法 相对于方法来说，计算属性会缓存计算的结果，只有计算属性的依赖项发生变化时，才会重新进行运算，因此计算属性的性能更好 # 自定义事件 在封装组件时，为了让组件的使用者可以监听到组件内状态的变化，此时需要用到组件的自定义事件 # 自定义事件的 3 个使用步骤 在封装组件时 # 声明自定义事件 开发者为自定义组件封装的自定义事件，必须事先在emits节点中声明 export default{ // 1. 声明自定义事件 emits:['change'], }# 触发自定义事件 在emits节点下声明的自定义事件，可以通过this.$emit(‘自定义事件的名称’) 方法进行触发 &lt;template&gt; &lt;div&gt; &lt;p&gt;count的值是：&lt;!--swig￼2--&gt;&lt;/p&gt; &lt;button @click=\"add\"&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default{ // 1. 声明自定义事件 emits:['countChange'], methods: { add() { this.count++ // 2.this.$emit () 触发自定义事件 this.$emit('countChange') } }}&lt;/script&gt; 在使用组件时 # 监听自定义事件 在使用自定义的组件时，可以通过v-on的形式监听自定义事件。 &lt;Counter @countChange=\"getCount\"&gt;&lt;/Counter&gt; methods: { getCount() { console.log('触发countChange事件') } }# 自定义事件传参。 在调用this.$emit()方法触发自定义事件时，可以通过第二个参数为自定义事件传参 this.$emit('countChange', this.count) // 触发自定义事件时，通过第二个参数传参 ====================== // 外界在监听 countChange 自定义事件时候可以通过事件处理函数的形参拿到最新的 count 值 getCount(val) { console.log('触发countChange事件,count值为:' + val) } # watch 监听器 watch 侦听器允许开发者监视数据的变化，从而针对数据的变化做待定的操作。例如监视用户名的变化并发起请求，判断用户是否可用。 # watch 侦听器的基本语法 开发者需要在 watch 节点下，定义自己的侦听器，要监听那个数据项的变化，就把那个数据项的名字作为方法的名称。 形参列表中，第一个参数代表 变化后的新值 ，第二个参数是 变化之前的旧值 export default { data() { return { username: '', } }, watch: { username(newVal, oldVal) { console.log('新：' + newVal, '旧：' + oldVal) }, }}# 小案例：检测用户名是否可用 监听 username 值的变化，并使用 axios 发起 Ajax 请求，检测当前输入的用户名是否可用 export default { data() { return { username: '', available: ' ', } },// 侦听器 watch: { async username(newVal, oldVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/${newVal}`) this.available = res.message; }, }}# immediate 选项 默认情况下，组件在初次加载完毕后不会调用 watch 侦听器。如果想让 watch 侦听器立即被调用，则需要使用immediate选项。 非常简单 watch 节点里加一个 immediate:true 即可 watch: { async username(newVal, oldVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/${newVal}`) this.available = res.message; }, // 组件加载完毕后立即调用一次当前的 watch 侦听器 immediate:true }# deep 选项 当watch 侦听的是一个对象，如果对象中属性值发生了变化，则无法被监听到。此时需要使用deep 选项 export default { data() { return { username: '', available: ' ', info: { username: 'zs' } } }, watch: { info: { //handler 属性是固定写法：当 username 发生了变化，调用 handler async handle(newVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/` + newVal) this.available = res.message; }, deep: true }, }}# 监听对象单个属性的变化 只想监听 info.username 的属性变化，可以把这个访问列声明过来即可 export default { data() { return { username: '', available: ' ', info: { username: 'zs', password:'' } } },// 侦听器 watch: { 'info.username': { // 只想监听 info.username 属性值的变化 async handle(newVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/` + newVal) this.available = res.message; }, deep: true }, }}","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue数据共享","slug":"Vue数据共享","date":"2022-04-10T11:39:29.000Z","updated":"2022-04-16T10:14:25.729Z","comments":true,"path":"2022/04/10/Vue数据共享/","link":"","permalink":"http://mrnobody233.github.io/2022/04/10/Vue%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/","excerpt":"","text":"# 组件之间的数据共享 # 在项目开发中，组件之间的关系分为如下 3 种 父子关系 兄弟关系 后代关系 # 父子之间的数据共享 父子组件之间的数据共享又分为 # 1. 父向子共享数据 父组件通过v-bind 属性绑定向子组件共享数据。同时，子组件需要使用props接收数据 父组件 // 父组件&lt;myTest :msg=\"message\" :user=\"userinfo\"&gt;&lt;/myTest&gt;data(){ return{ message:'hello vue', userinfo:{ name:'zs', age:20 } }}子组件 &lt;!-- 子组件 --&gt;&lt;template&gt; &lt;h3&gt;测试父子传值&lt;/h3&gt; &lt;p&gt;&lt;!--swig￼0--&gt;&lt;/p&gt; &lt;p&gt;&lt;!--swig￼1--&gt;&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default { name: \"MyTest\", props: ['msg', 'userinfo'],}&lt;/script&gt; # 2. 子向父共享数据 子组件通过自定义事件的方式向父组件共享数据。 在子组件中 先声明自定义事件 emits: ['MyTestCount'], 触发自定义事件 this.$emit('MyTestCount', this.count) // 子组件export default { // 1. 声明自定义事件 emits: ['MyTestCount'], data() { return { count: 0 } }, methods: { add() { this.count += 1; // 2. 数据发生变化时，触发自定义事件 this.$emit('MyTestCount', this.count) } }}在 父组件中 监听子组件的自定义事件 &lt;test @MyTestCount = 'getTestCount'&gt; &lt;/test&gt; 通过形参接收子组件传递过来的数据 &lt;!--父组件--&gt; &lt;!--1.监听子组件的自定义事件 @MyTestCount--&gt; &lt;MyTest @MyTestCount=\"getMyTestCount\"&gt;&lt;/MyTest&gt;&lt;script&gt;import MyTest from \"@/components/MyTest\";// 父组件export default { components: {MyTest,}, data() { return { count: 0, } }, methods: { getMyTestCount(val) { // 2. 通过形参，接收子组件传递过来的数据 this.count = val } }}&lt;/script&gt; # 3. 父与子双向数据同步 父组件在使用子组件期间，可以使用v-model 指令维护组件内外数据的双向同步 首先父组件通过属性绑定的形式，向子组件传递一个props数据 &lt;MySon v-model:num=\"count\"&gt;&lt;/MySon&gt; 接下来在子组件接收 props 并声明emits. 注意 emits 需要以 'update:要更新谁放谁' 形式写出来，这是一个固定写法 props:['num'] emits: ['update:num'], 接下来可以调用 this.$emit('update:xxx',最新的数据) 发送出去即可 add() { this.$emit('update:num', this.num + 1) } # 兄弟组件之间的数据共享 兄弟组件之间实现数据共享的方案是EventBus，可以接受第三方的包mitt来创建eventBus 对象，从而实现兄弟组件之间的数据共享 安装 mitt 依赖包 npm i mitt 创建公共的eventBus模块 // 导入 mitt 包import mitt from 'mitt'// 创建 EventBus 对象const bus = mitt()// 将 EventBus 的实例对象共享出去export default but 在数据接收方定义事件 在数据接收方调用bus.on(‘事件名’, 事件处理函数) 方法注册一个自定义事件 // 导入 eventBus.js 模块，得到共享的 bus 对象import bus from '@/eventBus/eventBus.js'export default { name: \"Right\", data() { return { count: 0 } }, created() { // 调用 bus.on () 方法注册一个自定义事件，通过事件处理函数的形参接收数据 bus.on('countChange', (num) =&gt; { this.count = num }) }} 在数据发送方触发事件 在数据发送方，调用bus.emit(‘事件名称’, 要发送的数据) 方法触发自定义事件 import bus from \"@/eventBus/eventBus.js\";export default { name: \"Left\", data() { return { num: 0 } }, methods: { addCount() { this.num++ // 调用 bus.emit () 方法触发自定义事件，并发送数据 bus.emit('countChange', this.num) } },}","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue路由","slug":"Vue路由","date":"2022-04-05T12:14:46.000Z","updated":"2022-04-21T13:40:54.321Z","comments":true,"path":"2022/04/05/Vue路由/","link":"","permalink":"http://mrnobody233.github.io/2022/04/05/Vue%E8%B7%AF%E7%94%B1/","excerpt":"","text":"# Vue 路由 路由就是Hash 地址与组件之间的对应关系 # 前端路由的工作方式 用户点击页面上的路由连接 导致了Url 地址栏中Hash值发生了变化 前端路由监听到了 Hash 地址的变化 前端路由把当前Hash 地址对应的组件渲染到浏览器中 结论：前端路由，指的是Hash 地址与组件之间的对应关系 # Vue-router Vue-router是 vue.js 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换 vue-router 3.x 只能结合vue2进行使用 vue-router 4.x 只能结合vue3进行使用 # 声明路由链接和占位符 可以使用 &lt;router-link&gt; 标签来声明路由链接，并使用 &lt;router-view&gt; 标签来声明路由占位符 &lt;template&gt; &lt;div&gt; &lt;h1&gt;App组件&lt;/h1&gt; &lt;!-- 声明路由连接 --&gt; &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/movie\"&gt;电影&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt;# 在 router/main.js 中导入 并注册组件 // 导入需要被展示的组件import Home from \"@/views/Home.vue\";import About from \"@/views/About.vue\";import Movie from \"@/views/Movie.vue\";const routes = [ //path 是 hash 地址 component 是要展示的组件 {path: '/home', component: Home}, {path: '/about', component: About}, {path: '/movie', component: Movie}] # 路由重定向 指的是：用户在访问地址 A的时候，强制用户跳转到地址 C，从而展示特定的组件页面 用法十分简单 通过路由规则的 redirect属性，指定一个新的路由地址，可以很方便的设置路由的重定向 const routes = [//path 表示需要被重定向的 “原地址”，redirect 表示将要被重定向到的 “新地址” {path: '/', redirect: '/home'},] # 嵌套路由 通过路由实现组件的嵌套展示，叫做嵌套路由 声明 子路由链接和子路由占位符 l&lt;!-- 在 About.vue 组件中，声明 tab1 和 tab2 的子路由连接以及子路由占位符 --&gt; &lt;div class=\"about\"&gt; &lt;h1&gt;About组件&lt;/h1&gt; &lt;hr&gt; &lt;!-- 声明子路由链接 --&gt; &lt;router-link to=\"/about/tab1\"&gt;tab1&lt;/router-link&gt;&amp;nbsp; &lt;router-link to=\"/about/tab2\"&gt;tab2&lt;/router-link&gt; &lt;hr&gt; &lt;!-- 声明子路由占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; 在父路由规则中，通过 children属性 嵌套声明子路由规则 // 导入需要的组件import Tab1 from \"@/views/tab/Table1.vue\";import Tab2 from \"@/views/tab/Table2.vue\";const routes = [ { path: '/about', name: 'About', component: About, // 在嵌套路由中使用路由重定向 redirect:'/about/tab1', children: [ // 通过 children 属性嵌套子路由规则 {path: 'tab1', component: Tab1}, {path: 'tab2', component: Tab2}, ] }]！！！注意 子路由规则的path 不要以 / 开头 这样写是错误的 children:[{path:'/tab1',component:Tab1}] # 路由的 query 传参 跳转路由并携带 query 参数 to 的字符串写法 &lt;router-link :to=\"`/home/message/detail?id=${m.id}$title=${m.title}`\"&gt;&lt;/router-link&gt;跳转路由并携带 query 参数 to 的对象写法 &lt;router-link :to=\"{ path:'/home/message/detail', query:{ id:m.id, title:m.title }}\"&gt; &lt;/router-link&gt;接收参数 $.route.query.id$.route.query.title # 命名路由 顾名思义 就是给路由取名字 非常简单 直接加一个 name 就可以了 作用就是可以简化路由的跳转 使用 {path: '/about', component: About, name: 'about'}, 简化 l&lt;!-- 简化前 需要写完整路劲 --&gt; &lt;router-link to=\"/demo/test/welcome\"&gt;欢迎&lt;/router-link&gt; &lt;!-- 简化后 直接通过名字跳转 --&gt; &lt;router-link to=\"{name:'hello'}\"&gt;欢迎&lt;/router-link&gt; &lt;!-- 检查写法配合传递参数 --&gt; &lt;router-link :to=\"{ name:'hello', query{ id:666, title:'欢迎欢迎', } }\"&gt; 欢迎 &lt;/router-link&gt; # 动态路由匹配 指的是把 Hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性。在 vue-router 中使用英文的冒号:来定义路由的参数项 &lt;router-link to=\"/movie/1\"&gt;电影1&lt;/router-link&gt; &amp;nbsp; &lt;router-link to=\"/movie/2\"&gt;电影2&lt;/router-link&gt; &amp;nbsp; &lt;router-link to=\"/movie/3\"&gt;电影3&lt;/router-link&gt; &amp;nbsp;路由中的动态参数以：进行声明，冒号后面是动态参数的名称 { path: '/movie/:id',name: 'Movie',component: Movie },# 获取动态路由参数值的两种方案 $route.params参数对象 通过动态路由匹配的方式渲染出来的组件中，可以使用 $route.params 对象访问到动态匹配的参数值 &lt;template&gt; &lt;div class=\"movie\"&gt; &lt;!--$route.params 是路由的 “参数对象”--&gt; &lt;h1&gt;Movie组件---------&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 使用 props 接收路由参数 为了简化路由参数的获取形式，vue-router 允许 路由规则中开启 props 传参 // 在 movie 组件中 以 props 的形式接收到路由规则匹配到的参数项// 第一种写法，值为对象，该对象中所有的 key-value 都会以 props 的形式传给 Movie 组件 { path: '/movie/:id', name: 'Movie', component: Movie, props: {a:1,b:'hello'} },// 第二种写法，值为布尔值，如果 props 的值为 true 就会把该路由组件收到的所有 params 参数，以 props 的形式传给 Movie 组件 { path: '/movie/:id', name: 'Movie', component: Movie, props: true },// 第三种写法，值为函数props($route){ return {id:$route.query.id,title:$route.query.title}}// 在 movie 组件中使用 props 接收路由规则中匹配到的参数项 props: ['id']&lt;!-- 直接使用 props 中接收的路由参数 --&gt; &lt;h1&gt;Movie组件----&lt;/h1&gt; # 编程式导航 通过调用 API实现导航的方式，叫做编程式导航，与之对应的，通过点击链接实现导航的方式，叫做声明式导航 普通网页中点击a 链接，vue 项目中点击router-link都属于声明式导航 普通网页中调用location.href跳转到新页面的方式，属于编程式导航 # vue-router 中的编程式 vue-router 提供了许多编程式导航 API，其中最常用的两个 API 分别是 this.$router.push (‘hash 地址’) 跳转到指定 hash 地址，从而展示对应的组件 this.$router.go (数值 n) 实现导航历史的前进，后退 # 路由守卫 路由守卫可以控制路由的访问权限 router.beforeEach((to, form, next) =&gt; { //to 目标路由对象 //from 当前导航正要离开的路由对象 //next 是一个函数 表示放行 const token = localStorage.getItem('token') if (to.path === '/main' &amp;&amp; !token) { //next (false) 不允许跳转 next('/login') // 强制跳转到 “登录页面” } else { next() // 直接放行， 允许访问 “后台主页” }}) # 路由器的两种工作模式 hash 模式： 地址中永远带着 #号 不美观 若以后将地址通过第三方手机 app 分享，诺 app 效验严格，则地址会被标记为不合法。 兼容性较好 history 模式 地址干净，美观 兼容性和 hash 模式相比略差 应用部署上线时需要后端人员支持，解决刷新页面服务端 404 问题","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue-ref引用-作用域插槽","slug":"Vue-ref引用-作用域插槽","date":"2022-04-03T06:21:20.000Z","updated":"2022-04-03T12:21:05.710Z","comments":true,"path":"2022/04/03/Vue-ref引用-作用域插槽/","link":"","permalink":"http://mrnobody233.github.io/2022/04/03/Vue-ref%E5%BC%95%E7%94%A8-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/","excerpt":"","text":"# ref 引用 ref 用来辅助开发者在不依赖 jQuery 的情况下，获取 DOM 元素或组件的引用 每个 vue 的组件实例上，都包含一个 $refs 对象，里面存储着对应的 DOM 元素或组件的引用。默认情况下，组件的 $ref 指向一个空对象。 # 使用 ref 引用 DOM 元素 使用 ref 属性 为对应的 DOM 添加引用名称 &lt;h1 ref=\"myh1\"&gt;App根组件&lt;/h1&gt; 通过 this.$refs.myh1 可以获取到 DOM 元素的引用 操作 DOM 元素把文本颜色改为红色 this.$refs.myh1.style.color='red'# 使用 ref 引用 组件 实例 使用 ref 属性 为相对应的组件添加引用名称 &lt;Counter ref=\"counterRef\"&gt;&lt;/Counter&gt; 通过 this.$refs.counterRef 可以引用组件的实例 引用到组件的实例之后，就可以调用组件上的 methods 方法 this.$refs.counterRef.reset()# this.$nextTick (cb) 方法 组件的 $nextTick (cb) 方法，会把 cb 回调推迟到下一个 DOM 更新周期之后执行，大概意思就是，等组件的 DOM 异步的重新渲染完成后，再执行 cb 回调函数，从而保证 cb 回调函数可以操作到最新的 DOM 元素。 this.$nextTick(()=&gt;{ this.$refs.ipt.focus() }) # 插槽 插槽 (Slot)是 vue 为组件封装者提供的能力。允许开发者在封装组件时，把不确定的，希望用户指定的部分定义为插槽。 可以把插槽认为是组件封装期间，为用户预留的内容的占位符 # 基础用法 在封装组件时，可以通过 &lt;slot&gt; 元素定义插槽，从而为用户预留内容占位符 &lt;template&gt; &lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--基本用法&lt;/h3&gt; &lt;hr&gt; &lt;p&gt;第一个p标签&lt;/p&gt; &lt;!-- 通过 slot 标签 为用户预留内容占位符 (插槽) --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;p&gt;最后一个p标签&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;用户在使用组件期间 为插槽指定具体内容 &lt;MyCom&gt; &lt;!-- 在使用组件时，为插槽指定具体的内容 --&gt; &lt;p&gt;---用户自定义的内容---&lt;/p&gt; &lt;/MyCom&gt;# 默认内容 封装组件，可以为预留的 &lt;slot&gt; 插槽提供默认内容。如果组件的使用者没有为插槽提供任何内容，则默认内容会生效 使用方式特别简单，在标签内写上默认内容即可 l&lt;template&gt; &lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--基本用法&lt;/h3&gt; &lt;hr&gt; &lt;p&gt;第一个p标签&lt;/p&gt; &lt;slot&gt;这是默认内容&lt;/slot&gt; &lt;p&gt;最后一个p标签&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;# 具名插槽 如果在封装组件时需要预留多个插槽节点，则需要为每个 &lt;slot&gt; 插槽指定具体的 name 名称。这种带有具体名称的插槽叫做 \"具名插槽\" &lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--基本用法&lt;/h3&gt; &lt;hr&gt; &lt;div&gt; &lt;slot name=\"title\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div&gt; &lt;main&gt;&lt;/main&gt; &lt;/div&gt; &lt;div&gt; &lt;slot name=\"user\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;在向具名插槽提供内容的时候，我们可以在 &lt;template&gt; 元素上使用v-slot, 并以 v-slot 的参数形式提供其名称 &lt;MyCom&gt; &lt;template v-slot:title&gt; &lt;p&gt;鹅鹅鹅&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:user&gt; &lt;p&gt;李白&lt;/p&gt; &lt;/template&gt; &lt;/MyCom&gt;具名插槽可以简写，(v-slot:) 替换为字符#。例如 v-slot:header 可以被重写为 #header # 作用域插槽 在封装组件的过程中，可以为预留的 &lt;slot&gt; 插槽绑定 props 数据，这种带有 props 数据的 &lt;slot&gt; 就是作用域插槽 &lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--作用域插槽&lt;/h3&gt; &lt;hr&gt; &lt;slot :info=\"userInfo\" :msg=\"message\"&gt;&lt;/slot&gt; &lt;/div&gt;v-slot:default=“任意合法名” 一般使用 scope 接收 接着可以使用插值表达式渲染出来 &lt;MyCom&gt; &lt;template #default=\"scope\"&gt; &lt;p&gt;&lt;/p&gt; &lt;/template&gt; &lt;/MyCom&gt;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Markor","slug":"Markor","date":"2022-04-02T03:57:05.000Z","updated":"2022-04-02T03:57:52.272Z","comments":true,"path":"2022/04/02/Markor/","link":"","permalink":"http://mrnobody233.github.io/2022/04/02/Markor/","excerpt":"","text":"# Markor 最近想了一小问题，就是学校解封以后，如果我回家的话基本上是不会碰电脑的，虽然我会把电脑一起带回去，但是基本上都没有打开过，可能是我觉得带着有重量感，不对，是害怕我的 github 没有保持日常提交代码，所以为了避免这个情况，我可以使用平板来写文档，虽然提交不上去，但是回宿舍以后，我也可以躺在床上用平板来写一写自己想写的东西，这样有挺多好处的，可以避免我在床上玩手机，这样就可以玩平板了，哈哈哈哈哈，为什么想要用平板来写文档呢，写博客什么的都不是最主要的，最重要的是让我的平板键盘能有用武之地，我已经太久没有用我的平板键盘了，一直放在抽屉里积灰，这东西花了我 600RMB，我也不知道当时我怎么想的，会买这么贵的东西。 好吧我突然想起来了，在我没有买显示器之前，平板一直是我的副屏，多亏了华为的多屏协同，能帮我省很多事，虽然延迟还是有一小丢丢，但是日常使用还是很给力的，即使是这样还是有缺点的，就是字太小了，我眼睛很好，但是一直看着这么小的字也是会很难受的，所以我买了显示器，果然大屏就是爽，立马抛弃了我的小平板，只用它来记笔记，我们三个一直相处的很好，直到有一天！！！我会写博客了，我为什么不把笔记写在博客里呢，所以我再次抛弃了我的平板，没有考虑平板的感受，呜呜，果然是买前生产力，买后哔哩哔哩，盖泡面，当手托，摸鱼。所以为了改变现状，我可以使用 Markor 来满足自己突然想写博客的欲望，这一篇博客就是使用 Markor 来写的，还挺像回事，如果找到更好的软件我还是会替代 Markor 的，哈哈哈哈哈哈，这样我的平板就不会失宠了。 日常水博客，就酱紫，拜拜。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"}]},{"title":"熬夜之旅","slug":"熬夜之旅","date":"2022-04-01T15:18:55.000Z","updated":"2022-04-01T16:03:25.378Z","comments":true,"path":"2022/04/01/熬夜之旅/","link":"","permalink":"http://mrnobody233.github.io/2022/04/01/%E7%86%AC%E5%A4%9C%E4%B9%8B%E6%97%85/","excerpt":"","text":"# 熬夜之旅 今天在工作室度过第一个夜晚，虽然在暑假比赛的时候已经住过另一个工作室了，但是这里还是头一次，和我一起的有社恐废宅充电器和胃病患者，比起宿舍我确实更喜欢这里，毕竟这里不需要交电费和水费，最主要的是还有空调可以吹，虽然室友都有比较好的作息时间，但在其他时间还是比较吵的，串门的比较多，所以非常感谢有这么好的环境提供给我学习和休息，今晚如果没有 SB 抢我的折叠床，我应该会睡的比较早。 # 其他的事 凌晨两点半的时候，有一个网友突然发现了我，她问我是谁，毕竟隔了四五年了，不记得我是谁也很正常，所以我稍微和她解释了一下，这样体现了给人写备注的好处。这个姑娘的也挺悲催的，所以我对她印象挺深刻，她和父母关系不好，有自残倾向，到了现在和她聊了一会，她告诉我在今年，也就是她的 18 岁那天，她自杀未遂，但是和父母关系好了一些，她说她重生了，我为她感到高兴，但也不敢问的太仔细，虽然她貌似想向我分享那些事情，但我还是把话题给往其他地方给放了，认识她是在一个仓鼠群里，我以前养过仓鼠，和她聊得比较好所以她加了我，并且告诉我她家里的一些事，当时我并不会安慰人，只是默默听着，让她有一个地方可以宣泄自己的压力，虽然现在也是一样，我还是不会安慰人，能感受的到别人悲伤的情绪，但也不会说什么，还可能会逃避。 扯多了，她问我怕蛇吗，我没回答，只是问她现在开始养蛇了嘛，和仓鼠放在一起不会出事吗，以及蛇没有咬过你吗，她说没有，倒是很想被咬一下试试，所以一不小心又回到了自残的话题，说自己又开始抽起了烟，本以为能缓解压力，结果压力更大了，每天晚上睡眠时间只有 5 小时，离她想上的大学平均分还差 2 分，也就是每科需要进步十分，我不敢多聊，因为太晚了，已经快凌晨 3 点了，所以告诉她生活的美好，以及还有很多没有碰到过的有意思的事情之类的，接着就睡了。 其实像这样的网友还有很多，以前聊的特别欢乐，突然有一天就没继续下去，也不知道是什么时候结束，但还是保存在自己的联系人里，默默的看着他们的变化，也是一种属于我自己的乐趣， # 最后 注意身体，不要熬夜现在是 2022 年 4 月 2 日 00:00:57，虽然标题是熬夜之旅，实际上是我想不出标题的名字而已，就酱紫，如果我再不睡，我的折叠床就要被傻逼玷污了！就酱紫，掰掰。还有一件事，这个标签是自言自语，看看就行了，全当我放屁，掰掰。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"}]},{"title":"Vue组件和props","slug":"Vue组件和props","date":"2022-04-01T06:50:11.000Z","updated":"2022-04-03T08:07:17.211Z","comments":true,"path":"2022/04/01/Vue组件和props/","link":"","permalink":"http://mrnobody233.github.io/2022/04/01/Vue%E7%BB%84%E4%BB%B6%E5%92%8Cprops/","excerpt":"","text":"# 组件 组件之间可以相互引用，首先得注册后使用 # 如何注册 注册组件的方式分为两种，全局注册 和 局部注册 被全局注册的组件，可以在全局任何一个组件内使用 / 被局部注册的组件，只能在当前注册的范围内使用 # 全局注册组件 在 main.js 中导入需要被全局注册 的组件 import Count from \"@/components/Count.vue\"; 调用 Vue.component () 方法全局注册组件 Vue.component('Count', Count) 在 app 组件中使用 Count 组件 &lt;Count&gt;&lt;/Count&gt; # 局部注册组件 在 app.vue 中导入需要被局部注册的组件 import Count from \"@/components/Count.vue\"; 在 components 节点下通过键值对的方式注册组件 components: { 'Count': Count, } 在 app 组件中使用 Count 组件 &lt;Count&gt;&lt;/Count&gt;# 全局注册和局部注册的区别 被全局注册的组件，可以在全局任何一个组件内使用 被局部注册的组件，只能在当前注册的方位内使用 # 组件的 props props 是组件的自定义属性，组件的使用者可以通过 props把数据传递到子组件内部，供子组件内部进行使用。 作用：父组件通过 props向子组件传递要展示的数据 好处：提高了组件的复用性 # 如何声明 props 在封装 Vue 组件时，可以把动态的数据项作为 props 自定义属性。自定义属性可以在当前组件的模板结构中被直接使用。 在子组件中声明两个要使用的 props 数据 比如向外界传递一个标题，作者 可以声明一个 props 数组 外界可以传递指定的数据，到当前的组件中 props:['title','author'] 然后可以在 DOM 结构中使用title的值和author 的值，使用插值表达式 {{}} 将两个值渲染到里面 &lt;div&gt; Article组件 &lt;h3&gt;标题：&lt;!--swig￼1--&gt;&lt;/h3&gt; &lt;h3&gt;作者:&lt;!--swig￼2--&gt;&lt;/h3&gt; 抽刀断水水更流，举杯消愁愁更愁 &lt;/div&gt; 接着在使用这个组件期间，可以传递两个数据的值 &lt;Article title=\"鹅鹅鹅\" author=\"木子日天\"&gt;&lt;/Article&gt; 也可以使用 v-bind 属性绑定的形式，为组件动态绑定 props 的值 &lt;Article :title=\"info.title\" :author=\"info.name\"&gt;&lt;/Article&gt;# props 验证 指的是：在封装组件时对外界传递过来的 props 数据进行合法性的效验，从而防止数据不合法的问题。 使用数组类型props 节点的话，无法为每个 props指定具体的数据类型 # 对象类型的 props 节点 使用对象类型的 props 节点，可以对每个 props 进行数据类型的效验 对象类型的 props 节点，提供了多种数据验证方案 基础的类型检查 props:{ //title 的属性值只能是数字类型 title:Number, } 多个可能的类型 props:{ //title 的属性值可以是 \"字符串\" 或者 \"数字\" title:[String,Number],} 必填项效验 props:{ title:{ type:String, // 表示当前属性的值必须是 String 字符串类型 required:true // 表示当前属性是 }} 属性默认值 props:{ age:{ type:Number, // 表示当前属性的值必须是 String 字符串类型 default:18, // 如果有使用者没有指定 age 的值 则它的默认值为 18 }} 自定义验证函数 # 动态组件 指的是动态的切换组件的显示与隐藏。vue 提供了一个内置的 &lt;component&gt; 组件，专门用来实现组件的动态渲染。 &lt;component&gt; 是组件的占位符 通过 is 属性 动态指定 要渲染的组件名称 &lt;component is=\"要渲染的组件的名称\"&gt;&lt;/component&gt; # 使用 keep-alive 保持这状态 默认情况下，切换动态组件时无法保持组件的状态。这样就可以使用 &lt;keep-alive&gt; 组件保持动态组件的状态 使用方式非常简单 &lt;keep-alive&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt; &lt;/keep-alive&gt;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"不要熬夜","slug":"不要熬夜","date":"2022-03-28T14:31:41.000Z","updated":"2022-03-29T02:18:45.328Z","comments":true,"path":"2022/03/28/不要熬夜/","link":"","permalink":"http://mrnobody233.github.io/2022/03/28/%E4%B8%8D%E8%A6%81%E7%86%AC%E5%A4%9C/","excerpt":"","text":"# 熬夜 # 起因 昨天和工作室的小伙伴们一起看社恐废宅充电器在玩一款新的游戏，叫做幽灵线：东京，我们更喜欢叫他林正英模拟器 对了那个游戏长这样确实比较新颖，因为他的攻击方式是把手比作枪，用手射出子弹一样，给人眼前一亮的感觉，但是玩久了感觉有点单调，不算很耐玩的游戏，也许是它太贵了我买不起，要 200 多 RMB。 # 然后 我们的社恐废宅充电器就开始了今天的熬夜，他花了一晚上的时间通关了幽灵线：东京，虽然是简单版的模式，但主要的是他通宵到到第二天中午才开始睡觉，这是他的睡姿 睡得和死了一样，这样的情况已经不是第一次了，我们也不是第一次提醒他，所以这里提前说明一下，如果他突然有一天走着走着就猝死了，希望他不要来找我，因为我已经提醒了很多次了， # 接着 在寒假的时候我也熬夜，但是没有他这么严重，最多熬到四五点，偶尔六点多起来去吃早餐，我记得五点半去的时候老板娘还没有准备好，所以我等到六点在去吃的，挖槽，原来早饭这么好吃，特别是那个猪血粉，等学校解封我回我奶奶家，一定得再去吃一次，现在想起来那个老板娘还是我小学同学的妈妈，她告诉我她女儿去参军了，两年以后才会回来，我倒是挺期待她能被改变成什么样，但是我最希望的是老板娘能送我瓶核桃味的早餐奶给我喝，我太喜欢喝了，噗哈哈。 # 最后 额，今天写的这个主要是做了一个新的分类，叫做自言自语，其目的是为了水博客，和分享关于自己有意思的事情，又或者是把自己可能会忘记的日常存在这里，所以最后还是点名一下主题把，就是希望我以后能少熬点夜，不能和那个 SB 一样，就当为了吃到好吃的猪血粉而努力吧，就这样，晚安～","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"}]},{"title":"实用网站","slug":"实用网站","date":"2022-03-26T13:19:12.000Z","updated":"2022-05-10T05:16:00.333Z","comments":true,"path":"2022/03/26/实用网站/","link":"","permalink":"http://mrnobody233.github.io/2022/03/26/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99/","excerpt":"","text":"# 实用网站 我的文件夹里有许多使用的网站，但也只是放在文件夹里，乱七八糟，没有整理，所以现在放在这里，以后就可以更加方便的利用这些网站 # 编程类 颜色网站 不知道如何配色可以看看介个网站 另一个颜色网站 这个也不错 取名鬼才不知道取什么变量名可以看看这个 阿里字库不管是网页还是 PS，又或者是 PPT，都可以用得上，真不错 # 图片类 wallpaper 壁纸 有许多挺不错的漂亮壁纸可以在这里看 搜图神器 可以搜索超清的好康的图片 主要我是荣耀捐赠会员 # 音乐类 刘志进音乐直连搜索 可以在这里搜索很多音乐 外链转换工具 可以配合上一个网站获得音乐的 mp3 网址 # 影视类 hwj 影视 可以看各种电影和番剧 (使用手机打开会有广告，推荐打开网页版 ) 寻剧吧 也是看各种电影和番剧 (使用手机打开会有广告，推荐打开网页版 ) 蜀黍的网站 你所热爱的就是你的生活 (陈睿 吃柠檬) 油管 可以在里面找乐子 0.0 要翻墙 # 娱乐类 今天吃什么 不知道吃什么可以看看介个 Picrew 随机生成头像，我的 github 的头像就是这里来的，是不是很好看 qwq 要翻墙 逗比拯救世界 很多各种各样的表情包，逗比必备哦。 # 其他 免费空间 学习 html css 的时候跟着pink老师找到的网站。 木子网 上传的大一下学期的期末作业，纯 html 和 css，做的好像比现在还好看许多，果然我把 css 忘光了。 查看综测分 查看综测分 学校选课 学校选修网课 # 无聊了继续更新 拜拜","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"网站","slug":"网站","permalink":"http://mrnobody233.github.io/tags/%E7%BD%91%E7%AB%99/"},{"name":"工具","slug":"工具","permalink":"http://mrnobody233.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Vue指令","slug":"Vue指令","date":"2022-03-26T09:33:02.000Z","updated":"2022-05-13T03:44:55.888Z","comments":true,"path":"2022/03/26/Vue指令/","link":"","permalink":"http://mrnobody233.github.io/2022/03/26/Vue%E6%8C%87%E4%BB%A4/","excerpt":"","text":"# Vue 指令 虽然学习完了 Vue，但还有许多地方木有掌握，所以今天就来复习一下 Vue 还没有掌握的指令 按键修饰符 条件渲染指令 循环渲染指令 虽然只有一些内容，但还是要认真的写下去，不然就得去平板看我写的丑不拉几的字，我实在不忍心看下去，这也是在这里复习的原因之一。 # 按键修饰符 在监听键盘事件的时候，我们需要判断详细的按键，此时，可以为键盘相关的事件添加按键修饰符 举一个非常简单的案例，当我们在登录页面输入完密码之后，按下回车键后使用 Ajax 发送数据 如何实现捏？ 我们可以使用 @keyup 事件 &lt;input type=\"password\" @keyup.enter=\"commitAjax\"&gt; 这样在 input 表单中按下回车键就可以触发方法了 非常的方便，学废了。 # 条件渲染指令 这个好像挺简单的，既然打出来了，全当复习用了 这个东西主要用来辅助开发者按需控制 DOM 的显示与隐藏 但是条件渲染指令有两个 v-if v-show 两者区别不大 但还是要讲一讲 继续举一个简单地例子 &lt;p v-if=\"flag\"&gt;这是被 v-if 控制的元素&lt;/p&gt;&lt;!-- ------- 当 flag 为 false 的时候两者都会隐藏 但是隐藏的方法不一样 -------- --&gt;&lt;p v-show=\"flag\"&gt;这是被 v-show 控制的元素&lt;/p&gt;v-if 会动态创建元素或者移除 v-show 则是给元素添加 display:none; 样式 来实现元素的显示和隐藏 差点忘记了还有一个 v-else v-else 指令必须搭配 v-if 来进行使用 否则将不会被识别 来看个简单地例子就会了 &lt;div v-if=\"type === 'A'\"&gt;优秀&lt;/div&gt; &lt;div v-else-if=\"type === 'B'\"&gt;良好&lt;/div&gt; &lt;div v-else-if=\"type === 'C'\"&gt;一般&lt;/div&gt; &lt;div v-else&gt;差&lt;/div&gt;是不是很简单呢 # 循环渲染指令 实际上这个才是我要复习的内容，前面两个都太简单了，虽然这个也是，看看文档就会了，但是为了以后不用看文档，所以才认真写一写吧 V-for 列表渲染指令，用于开发者基于一个数组来循环渲染一个列表结构 先来看看代码 data:{ // 列表数据 list[ {id: 1 ,name: '木子日天' }, {id: 2 ,name: '李日天' }, {id: 3 ,name: '木子昊' }, ]}要循环那个 DOM 就给那个加上 v-for=\"item in list\" &lt;div v-for='item in list'&gt; &lt;p&gt; ,&lt;/p&gt;&lt;/div&gt;item 是循环的每一项 list 是被循环的数组 结果就是 1,木子日天 2,李日天 3,木子昊使用了 v-for 指定那么一定要绑定一个 :key 属性 &lt;div v-for=\"item in list\" :key=\"item.id\"&gt; &lt;p&gt; ,&lt;/p&gt;&lt;/div&gt;就酱紫 拜拜","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"First_Vue_Web","slug":"First-Vue-Web","date":"2022-03-25T10:45:09.000Z","updated":"2022-03-26T09:11:36.909Z","comments":true,"path":"2022/03/25/First-Vue-Web/","link":"","permalink":"http://mrnobody233.github.io/2022/03/25/First-Vue-Web/","excerpt":"","text":"# 原因 因为我的同学胃病患者在上学期参加了，信工的移动安卓设计比赛，并获得了二等奖，我很是心动 ，并不是心动二等奖，而是心动因为二等奖获得的雷蛇鼠标，虽然我已经买了一个比他更贵的鼠标，但是我好不爽，能白嫖为什么要买，所以我下定决心，去参加了这个学期的网站设计大赛，获得更高的奖品，至少给我一个雷蛇键盘 # 想法 正好最近学完 Vue, 有用武之地，为了不让知识悄悄溜走，所以我决定使用 Vue 来制作本次项目，询问了举办方老师，可以使用 Vue 之类的东东，所以很快啊，我立马新建文件夹，可是不知道做什么类型的东西，思考许久，终于！！ 我决定做一个做烂的东西，也就是我们工作室的网站，但是是 SPA（单页应用程序），想法有了，就有动力去做了。正好比赛需要上交一份 PPT，也就顺便把 SPA 的介绍在博客里面写好，这样就不用再去百度了，我真聪明，哈哈哈哈哈哈！。 # SPA（单页面应用程序） # 1. 什么是单页面应用程序 单页面应用程序 （英文名:Single Page Application）简称 SPA，顾名思义，指的就是一个 Web 网站中只有唯一一个 HTML 页面，所有的功能和交互都在这唯一的一个页面内完成 # 2. 单页面应用程序的特点 单页面应用程序将所有的功能局限于一个 web 页面中。仅在该 web 页面初始化时加载相应的资源（HTML，JavaScript，CSS） 一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转。而是利用 JavaScript 动态的变换 HTML 内容，从而实现用户的交互。 # 3. 单页应用程序的优点 # 良好的交互体验 单页面应用的内容的改变不需要重新加载整个页面 获取数据也是通过 Ajax 异步获取 没有页面之间的跳转，所以不会出现 “白屏现象” # 良好的前后端工作分离模式 后端专注于提供 API 接口，更容易实现 API 接口的附庸 前端专注于页面的渲染，更利于前端工程化的发展 # 减轻服务器的压力 服务器只需提供数据，不负责页面的合成与逻辑的处理，吞吐能力会提高几倍。 # 4. 单页应用程序的缺点 1. 首屏加载慢 2. 不利于 SEO # 长啥样？ 说了这么久那么做的到底咋样呢？实际上不怎么地，在制作期间参考了许多网站，包括学长写过的工作室网站发现我写的实在是太垃圾了，简直就是一坨屎一样，不过好歹是我第一次完成 Vue 作品，也使用了大量的 Vant 组件和 Element 组件，整体看起来不算很丑（自我安慰），相信我以后技术成熟了能够更加完善这个项目，不用再参考公众号的布局。哈哈，那么就来看一看吧。 # 长这样。 # 这样。 # 和这样 没有全截完 但是也可以看出 制作水平很一般了。 所以还需再接再厉。拜拜～","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://mrnobody233.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"不要被外表迷惑","slug":"不要被外表迷惑","date":"2022-03-25T05:30:58.000Z","updated":"2022-04-21T13:41:42.031Z","comments":true,"path":"2022/03/25/不要被外表迷惑/","link":"","permalink":"http://mrnobody233.github.io/2022/03/25/%E4%B8%8D%E8%A6%81%E8%A2%AB%E5%A4%96%E8%A1%A8%E8%BF%B7%E6%83%91/","excerpt":"","text":"本来这个博客很早就可以完成的，都怪我被迷惑了，因为那个网站实在是太漂亮了，我也想整一个 就是这个网站 (可以点我)，他实在是太漂亮了，原来网站可以这么漂亮，所以我决定使用这个网站，但是发现他的配置文件完全看不懂，我实在是太菜了。 感觉自己白学前端了，所以我下定决心，毕业以后一定不要做程序员 还是去送外卖好了 QWQ, 所以今天我学废了，自己垃圾就不要去看大佬作品，否则会怀疑人生，马上自闭。 就酱紫，拜拜～～","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"}]}],"categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"},{"name":"待办","slug":"待办","permalink":"http://mrnobody233.github.io/tags/%E5%BE%85%E5%8A%9E/"},{"name":"Ajax","slug":"Ajax","permalink":"http://mrnobody233.github.io/tags/Ajax/"},{"name":"网站","slug":"网站","permalink":"http://mrnobody233.github.io/tags/%E7%BD%91%E7%AB%99/"},{"name":"工具","slug":"工具","permalink":"http://mrnobody233.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"},{"name":"周记","slug":"周记","permalink":"http://mrnobody233.github.io/tags/%E5%91%A8%E8%AE%B0/"},{"name":"CSS","slug":"CSS","permalink":"http://mrnobody233.github.io/tags/CSS/"},{"name":"axios","slug":"axios","permalink":"http://mrnobody233.github.io/tags/axios/"},{"name":"项目","slug":"项目","permalink":"http://mrnobody233.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]}