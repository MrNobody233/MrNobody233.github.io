{"meta":{"title":"MrNobody's Blog","subtitle":"保持呼吸 不要断气","description":"MrNobody","author":"Mr_Nobody","url":"http://mrnobody233.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-03-25T12:46:37.000Z","updated":"2022-03-25T12:46:55.821Z","comments":true,"path":"categories/index.html","permalink":"http://mrnobody233.github.io/categories/","excerpt":"","text":""},{"title":"","date":"2022-04-05T12:26:49.554Z","updated":"2022-04-05T12:26:49.554Z","comments":true,"path":"about/index.html","permalink":"http://mrnobody233.github.io/about/","excerpt":"","text":"关于为什么会有这个博客，因为我写的第一个Vue项目里面想添加一个友情链接，跳转到我的个人博客，但是我并没有博客，所以我从今天，也就是2022年3月25日13:39:38 诞生了我的第一个博客。 虽然这个博客的主题很漂亮，叫做Diaspora，但是我写不出来，我太菜了，也许有朝一日我能写出属于自己主题的博客 介绍我叫木子曰天，我今年好多岁了，我是个男孩子，马上就要大三了，还是一个什么都不会的垃圾。 如果想要找垃圾玩，可以坐火车到南昌西站，在坐地铁一号线到双港，最后拨打我的电话就行。我性格古怪，脏话连篇，看到熟人会对他放屁，看到我可以立马跑掉,我的QQ是,最好是加我的telegram PS:需要翻墙 技能点 1.我亚索很厉害 2.CSGO摆烂很厉害 3.会一些web前端 4.可以像猴子一样到处乱爬 5.骂人很厉害 6.掐人很痛 7.放屁很臭 8.鼻屎攻击 9.阴阳怪气 10.别人在我面前我可以把他帅死 11.取名鬼才(详细可查看下方友情链接) 好友的博客 @butterflyFish @果果超甜 @胃病患者 @社恐废宅充电器"},{"title":"search","date":"2022-03-26T13:09:20.000Z","updated":"2022-03-26T13:10:30.800Z","comments":true,"path":"search/index.html","permalink":"http://mrnobody233.github.io/search/","excerpt":"","text":""},{"title":"tags","date":"2022-03-25T12:47:43.000Z","updated":"2022-03-25T12:47:59.970Z","comments":true,"path":"tags/index.html","permalink":"http://mrnobody233.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"凌晨校园","slug":"凌晨校园","date":"2022-04-17T16:06:15.000Z","updated":"2022-04-18T12:56:54.958Z","comments":true,"path":"2022/04/18/凌晨校园/","link":"","permalink":"http://mrnobody233.github.io/2022/04/18/%E5%87%8C%E6%99%A8%E6%A0%A1%E5%9B%AD/","excerpt":"","text":"第二次本来想在工作室过夜写会儿代码的，但是在十一点四十的时候果果超甜突然告诉我明天早上要做核酸，TNND，我真的受不了了，明明今天已经做过了，居然连续做两天，所以我准备回宿舍，不过红绿蓝并不是只有我一个人，还有一个老师也在，整个地方只有他的办公室还是亮着的，为了不让他发现我在这里，我小心的打开自己办公室的门，然后悄咪咪的溜到大门口，这个真的是高难度，因为大门太重了，开的时候会发出嘎吱嘎吱的响声，我也经常在办公室听大门的开关声来判断是否有人进来。所以结局很正常，我被他发现了，关键是我打都没打开门，因为门被锁了，而且还是磁力锁，我来这里三个学期了都没有看到他们打开磁力，今天TMD突然就打开了，然后老师就说了一句 谁？ 把我尬死在原地，我故作镇定，回答：还能出去吗？ 然后他说待会走。 然后我就默默的回到自己的办公室打开小灯开始看自己的代码，尬的我连刚刚学的Vuex传值都不会了，加上我尿急，我都快绷不住了，过了好一会儿他来了，说 走吧 ，问我为什么这么晚还没回宿舍，我说项目还有一些需要改的地方，他也没多问，出去的时候我才知道，磁力门并不是那个老师弄的，他也尝试拉了一下门，和我一样打不开，我按了一下右边的按钮就开了，接着就在外面等他锁门，拿手电筒照着他，看他锁门，尬死我了，心里想赶紧让我先走吧，然后他就让我先回去了，哎，还好他没问我这么晚了怎么回宿舍，不然我真的答不出来。 宿舍离工作室也不算很远，不过路上还是特别可怕的，第一个是太黑了一点灯都没有，第二个是太冷了，第三个就是妈的那个SB孔雀突然叫了一下，把我吓得鸡皮疙瘩都起来了，搞不明白为什么孔雀要放在我宿舍对面，现在住在这栋宿舍的人每天都在群里想着怎么杀掉这几个孔雀。 终于到了老地方，那颗支撑我回宿舍的小树，看来多锻炼还是特别有用的，对于我来说通过这个树上二楼是一件非常轻松的事情，也许是我太轻了，手臂能够把我支撑起来，就这样我安全都回去了。 第一次实际上这并不是我第一次这么晚还在学校外面溜达，在几号来着。。也就前几天吧，因为一些原因，果果超甜，胃痛患者，还有我很晚的时候在外面溜达，本来想着等老师走了以后再回工作室的，在外面溜达了好一会儿，终于来学校这么久了找到古茗的位置了，还有我去年暑假留校做比赛经常点的外卖的位置，那个炸鸡真的太好吃了，还看见了我们学校的留学生在操场用音响放音乐，如果不是封校了，我们肯定会出去溜达的，真的可惜呀，， 过了好一会我们准备回工作室了，结果发现二楼大门被锁了。。通常是一楼被锁的，我们可以从食堂小门进去，但是二楼被锁了实在就无能为力了。期间尝试了很多方法进去，结果也就我能实现，可以从厕所那里爬过去，也就爬两个小房间的高度，然后抓着钢管到男厕所窗口就可以了，我示范了一遍给他们看，但是到钢管哪里我就没爬了，太黑了，为了安全考虑我和他们一起回宿舍了，还是熟悉的位置，我第一个爬上去了，能感觉到树枝被裁剪了许多，相比之前爬难了一点点点点，但是对于他们来说就特别困难了，努力了半天，他们终于也上来了，看得我心惊胆跳的，真是捏了一把汗，如果失误了从上面摔下来，也就一条腿骨折而已，如果没站稳脑袋磕到石头了也就一辈子躺床上罢了。安全的回到了宿舍，可是 胃痛患者 并不想回自己宿舍，因为和室友关系不好什么的，所以我善心大方收留了他 ，也就是这个决定，让我尬死了一晚上 那个时候太热了，又热又闷的，我想去开空调，但是空调线没插，我想过去插线，可是那边室友已经睡着了，所以结局很明了，我把线插好了，也把室友吵醒了被骂了一顿，可以说是我今年最尬的时候了，那晚过的很煎熬，果然我还是比较适合一个人睡，如果废宅充电器在的话就好了，他可以一晚上不睡，然后让胃痛患者睡他床，不过想想也不可能，因为不知道他们宿舍怎么上二楼，不过我以后再也不会让别人和我一起挤那么小的床睡觉了。拜拜 这次写的太粗略了，很多细节都没有写，可能是这一篇生活写的太多了，而且现在已经12：48了，明天还得早起做核酸，，等过几年我突然想起来了更多细节，也许会补充上去吧？也许。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"}]},{"title":"Vue-Vuex","slug":"Vue-Vuex","date":"2022-04-14T12:22:26.000Z","updated":"2022-04-18T12:52:25.343Z","comments":true,"path":"2022/04/14/Vue-Vuex/","link":"","permalink":"http://mrnobody233.github.io/2022/04/14/Vue-Vuex/","excerpt":"","text":"Vuex 概述组件之间共享数据 父向子传值：v-bind 属性绑定 子向父传值：自定义事件 兄弟之间共享数据：EventBus $on 接收数据的那个组件 $emit 发送数据的那个组件 以上传值只适合小范围，如果需要频繁的大范围的共享就可使用vuex Vuex 是什么是实现组件全局状态(数据) 管理的一种机制，可以方便的实现组件之间数据的共享 使用Vuex统一管理状态的好处 能够在 vuex 集中管理共享的数据，易于开发和后期维护 能够高效地实现组件之间的数据共享，提高开发效率 存储在vuex中的数据都是响应式的，能够实时保持数据与页面的同步 Vuex 的基本使用1. 安装 vuex 依赖包npm i vuex -s 2. 导入 vuex 包import Vuex from 'vuex'Vue.use(Vuex) 3.创建 store 对象、1234const store = new Vuex.store({ // state 中存放的就是全局共享的数据 state:{ count: 0 }}) 4.将 store 对象挂载到 vue 实例中12345678new Vue({ el:'#app', render:h=&gt;h(app), router, // 将创建的共享数据，挂载到Vue实例中 // 所有的组件，就可以直接从 store 中获取全局的数据了 store}) vuex的核心概念Vuex中的主要核心概念如下： State Mutation Action Getter Statestate提供位移的公共数据源，所有共享的数据都要统一放到Store的State中进行存储 1234// 创建store数据源，提供唯一公共数据const store = new Vuex.Store({ state: { count: 0 }}) 组件访问State中数据的 第一种方式： 1`this.$store.state.全局数据名称 组件访问State中数据的 第二种方式： 12// 1.从 vuex 中按需导入mapState函数import { mapState } from 'vuex' 通过刚才导入的mapState函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性 1234// 2.将全局数据，映射为当前组件的计算属性computed:{ ...mapStated(['count'])} MutationMutation 用于变更 Store 中的数据。 只能通过 mutation 变更 Store 数据，不可以直接操作 Store 中的数据 通过这种方式虽然操作起来繁琐一些，但是可以集中监控所有数据的变化 123456789101112// 定义 Mutationconst store = new Vuex.store({ state:{ count: 0 }, mutations: { add(state) { // 变更状态 state.count++ } },}) 1234567// 触发mutationmethods: {btnHandler1() { // 触发mutation的第一种方式 this.$store.commit('add') }} 可以在触发mutations时传递参数 123456mutations: { add(state, step) { // 变更状态 state.count += step }}, 1234567methods: { btnHandler1() { // 在调用 commit 函数， // 触发mutations 时携带参数 this.$store.commit('addN', 3) }} this.$store.commit()是触发mutations的第一种方式，触发mutations的第二种方式： 12// 1. 从vuex中按需导入 mapMutations函数import { mapMutations } from 'vuex' 通过刚才导入的mapMutations函数 将需要的 mutations 函数 映射为当前组件的methods方法： 1234567891011// 2. 将指定的mutations函数 映射为当前组件的methods函数methods: { ...mapMutations(['sub', 'subN']), reduction1() { this.sub() }, reduction2() { this.subN(3) } } ActionAction 用于处理异步任务如果通过异步操作变更数据，必须通过Action，而不能使用Mutation，但是在Action中还是要通过触发mutation的方式间接变更数据。 定义Action 123456789101112131415161718// 只有 mutation 中定义的函数，才有权力修改 state 中的数据 mutations: { add(state) { // 不要在 mutations 函数中 执行异步操作 /* setTimeout(() =&gt; { state.count++ },1000)*/ state.count++ }, }, actions: { addAsync(context) { setTimeout(() =&gt; { // 在 actions 中,不能直接修改 state 中的数据 // 必须通过 context.commit() 触发 某个 mutation 才行 context.commit('add') }, 1000) } 触发Action 123456methods:{ handle(){ // 触发 actions 的第一种方式 this.$store.dispath('addAsync') }} 触发 actions 异步任务时携带参数: 12345678910111213mutations: { addN(state, step) { // 变更状态 state.count += step },},actions: { addNAsync(context, step) { setTimeout(() =&gt; { context.commit('addN', step) }, 1000) }}, 123btnHandlerWaitN() { this.$store.dispatch('addNAsync', 3)} this.$store.dispath() 是触发 actions 的第一种方式，触发actions的 第二种方式： 12// 1. 从vuex中按需导入 mapActions函数import { mapActions } from 'vuex' 通过刚才导入的mapActions函数，将需要的actions函数，映射为当前组件的methods方法： 123methods:{ ...mapActions(['addAsync','addNsync'])} GetterGetter 用于对Store中的数据进行加工处理形成新的数据。 Getter 可以对Store中已有的数据加工处理之后形成新的数据，类似Vue的计算属性。 Store中数据发生变化，Getter的数据也会跟着变化。 1234export default new Vuex.Store({ state: { coun 使用getters的第一种方式 1&lt;h3&gt;{{ this.$store.getters.名称 }}&lt;/h3&gt; 使用getters的第二种方式 12345678910&lt;h1&gt;{{ showNum }}&lt;/h1&gt;import { mapGetters} from 'vuex' computed: { ...mapGetters(['showNum']) },","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue计算属性-自定义事件-watch监听器","slug":"Vue计算属性-自定义事件-watch监听器","date":"2022-04-10T12:11:01.000Z","updated":"2022-04-13T12:04:21.108Z","comments":true,"path":"2022/04/10/Vue计算属性-自定义事件-watch监听器/","link":"","permalink":"http://mrnobody233.github.io/2022/04/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6-watch%E7%9B%91%E5%90%AC%E5%99%A8/","excerpt":"","text":"计算属性计算属性本质上就是一个function函数,它可以实时监听data中数据的变化，并return一个计算后的新值，供组件渲染DOM时使用 声明计算属性计算属性需要以function函数的形式声明到组件的computed节点中，示例代码如下 123456789101112131415161718&lt;input type=\"text\" v-model.number=\"count\"&gt;&lt;p&gt;{{count}}乘以 2 的值为：{{ plus }} &lt;/p&gt;&lt;script&gt; export default { data(){ return{ count:1, } }, computed:{ plus(){ // 计算属性，监听 data 中 count 的变化，自动计算出 count * 2 之后的新值 return this.count * 2 } } }&lt;/script&gt; 计算属性的使用注意点 计算属性必须定义在computed节点中 计算属性必须是一个function的函数 计算属性必须有 return 返回值！！ 计算属性必须当作普通属性使用 计算属性 vs 方法相对于方法来说，计算属性会缓存计算的结果，只有计算属性的依赖项发生变化时，才会重新进行运算，因此计算属性的性能更好 自定义事件在封装组件时，为了让组件的使用者可以监听到组件内状态的变化，此时需要用到组件的自定义事件 自定义事件的3个使用步骤 在封装组件时 声明自定义事件开发者为自定义组件封装的自定义事件，必须事先在emits节点中声明 1234export default{ // 1.声明自定义事件 emits:['change'],} 触发自定义事件在emits节点下声明的自定义事件，可以通过this.$emit(‘自定义事件的名称’)方法进行触发 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;p&gt;count的值是：{{ count }}&lt;/p&gt; &lt;button @click=\"add\"&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default{ // 1.声明自定义事件 emits:['countChange'], methods: { add() { this.count++ // 2.this.$emit() 触发自定义事件 this.$emit('countChange') } }}&lt;/script&gt; 在使用组件时监听自定义事件 在使用自定义的组件时，可以通过v-on的形式监听自定义事件。 12345678&lt;Counter @countChange=\"getCount\"&gt;&lt;/Counter&gt; methods: { getCount() { console.log('触发countChange事件') }} 自定义事件传参。在调用this.$emit()方法触发自定义事件时，可以通过第二个参数为自定义事件传参 12345678this.$emit('countChange', this.count) // 触发自定义事件时，通过第二个参数传参======================// 外界在监听countChange自定义事件时候可以通过事件处理函数的形参拿到最新的 count值 getCount(val) { console.log('触发countChange事件,count值为:' + val) } watch 监听器watch侦听器允许开发者监视数据的变化，从而针对数据的变化做待定的操作。例如监视用户名的变化并发起请求，判断用户是否可用。 watch侦听器的基本语法开发者需要在watch节点下，定义自己的侦听器，要监听那个数据项的变化，就把那个数据项的名字作为方法的名称。 形参列表中，第一个参数代表 变化后的新值 ，第二个参数是 变化之前的旧值 12345678910111213export default { data() { return { username: '', } }, watch: { username(newVal, oldVal) { console.log('新：' + newVal, '旧：' + oldVal) }, }} 小案例:检测用户名是否可用监听username值的变化，并使用axios发起Ajax请求，检测当前输入的用户名是否可用 123456789101112131415export default { data() { return { username: '', available: ' ', } },// 侦听器 watch: { async username(newVal, oldVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/${newVal}`) this.available = res.message; }, }} immediate选项默认情况下，组件在初次加载完毕后不会调用watch侦听器。如果想让watch侦听器立即被调用，则需要使用immediate选项。 非常简单 watch节点里加一个immediate:true即可 1234567891011watch: { async username(newVal, oldVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/${newVal}`) this.available = res.message; }, // 组件加载完毕后立即调用一次当前的watch侦听器 immediate:true} deep选项当watch侦听的是一个对象，如果对象中属性值发生了变化，则无法被监听到。此时需要使用deep选项 123456789101112131415161718192021export default { data() { return { username: '', available: ' ', info: { username: 'zs' } } }, watch: { info: { // handler属性是固定写法：当username发生了变化，调用handler async handle(newVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/` + newVal) this.available = res.message; }, deep: true }, }} 监听对象单个属性的变化只想监听info.username的属性变化，可以把这个访问列声明过来即可 1234567891011121314151617181920212223export default { data() { return { username: '', available: ' ', info: { username: 'zs', password:'' } } },// 侦听器 watch: { 'info.username': { // 只想监听 info.username属性值的变化 async handle(newVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/` + newVal) this.available = res.message; }, deep: true }, }}","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue数据共享","slug":"Vue数据共享","date":"2022-04-10T11:39:29.000Z","updated":"2022-04-16T10:14:25.729Z","comments":true,"path":"2022/04/10/Vue数据共享/","link":"","permalink":"http://mrnobody233.github.io/2022/04/10/Vue%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/","excerpt":"","text":"组件之间的数据共享在项目开发中，组件之间的关系分为如下3种 父子关系 兄弟关系 后代关系 父子之间的数据共享父子组件之间的数据共享又分为 1. 父向子共享数据父组件通过v-bind属性绑定向子组件共享数据。同时，子组件需要使用props接收数据 父组件 123456789101112// 父组件&lt;myTest :msg=\"message\" :user=\"userinfo\"&gt;&lt;/myTest&gt;data(){ return{ message:'hello vue', userinfo:{ name:'zs', age:20 } }} 子组件 12345678910111213&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;h3&gt;测试父子传值&lt;/h3&gt; &lt;p&gt;{{ msg }}&lt;/p&gt; &lt;p&gt;{{ userinfo }}&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default { name: \"MyTest\", props: ['msg', 'userinfo'],}&lt;/script&gt; 2. 子向父共享数据子组件通过自定义事件的方式向父组件共享数据。 在子组件中 先声明自定义事件 emits: ['MyTestCount'], 触发自定义事件 this.$emit('MyTestCount', this.count)123456789101112131415161718// 子组件export default { // 1. 声明自定义事件 emits: ['MyTestCount'], data() { return { count: 0 } }, methods: { add() { this.count += 1; // 2.数据发生变化时，触发自定义事件 this.$emit('MyTestCount', this.count) } }} 在 父组件中 监听子组件的自定义事件 &lt;test @MyTestCount = 'getTestCount'&gt; &lt;/test&gt; 通过形参接收子组件传递过来的数据 123456789101112131415161718192021222324&lt;!--父组件--&gt; &lt;!--1.监听子组件的自定义事件 @MyTestCount--&gt; &lt;MyTest @MyTestCount=\"getMyTestCount\"&gt;&lt;/MyTest&gt;&lt;script&gt;import MyTest from \"@/components/MyTest\";// 父组件export default { components: {MyTest,}, data() { return { count: 0, } }, methods: { getMyTestCount(val) { // 2. 通过形参，接收子组件传递过来的数据 this.count = val } }}&lt;/script&gt; 3. 父与子双向数据同步 父组件在使用子组件期间，可以使用v-model指令维护组件内外数据的双向同步 首先父组件通过属性绑定的形式，向子组件传递一个props数据1&lt;MySon v-model:num=\"count\"&gt;&lt;/MySon&gt; 接下来在子组件接收props并声明emits.注意emits需要以'update:要更新谁放谁'形式写出来，这是一个固定写法 12props:['num']emits: ['update:num'], 接下来可以调用this.$emit('update:xxx',最新的数据) 发送出去即可123add() { this.$emit('update:num', this.num + 1) } 兄弟组件之间的数据共享兄弟组件之间实现数据共享的方案是EventBus，可以接受第三方的包mitt来创建eventBus对象，从而实现兄弟组件之间的数据共享 安装mitt 依赖包 npm i mitt 创建公共的eventBus模块123456789// 导入mitt包import mitt from 'mitt'// 创建EventBus对象const bus = mitt()// 将EventBus的实例对象共享出去export default but 在数据接收方定义事件 在数据接收方调用bus.on(‘事件名’,事件处理函数)方法注册一个自定义事件 123456789101112131415161718// 导入eventBus.js模块，得到共享的bus对象import bus from '@/eventBus/eventBus.js'export default { name: \"Right\", data() { return { count: 0 } }, created() { // 调用bus.on()方法注册一个自定义事件，通过事件处理函数的形参接收数据 bus.on('countChange', (num) =&gt; { this.count = num }) }} 在数据发送方触发事件 在数据发送方，调用bus.emit(‘事件名称’,要发送的数据)方法触发自定义事件 1234567891011121314151617import bus from \"@/eventBus/eventBus.js\";export default { name: \"Left\", data() { return { num: 0 } }, methods: { addCount() { this.num++ // 调用bus.emit()方法触发自定义事件，并发送数据 bus.emit('countChange', this.num) } },}","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue路由","slug":"Vue路由","date":"2022-04-05T12:14:46.000Z","updated":"2022-04-07T12:37:26.362Z","comments":true,"path":"2022/04/05/Vue路由/","link":"","permalink":"http://mrnobody233.github.io/2022/04/05/Vue%E8%B7%AF%E7%94%B1/","excerpt":"","text":"Vue路由路由就是Hash地址与组件之间的对应关系 前端路由的工作方式 用户点击页面上的路由连接 导致了Url地址栏中Hash值发生了变化 前端路由监听到了Hash地址的变化 前端路由把当前Hash地址对应的组件渲染到浏览器中 结论：前端路由，指的是Hash 地址与组件之间的对应关系 Vue-routerVue-router是vue.js官方给出的路由解决方案。它只能结合vue项目进行使用，能够轻松的管理SPA项目中组件的切换 vue-router 3.x 只能结合vue2进行使用 vue-router 4.x 只能结合vue3进行使用 声明路由链接和占位符可以使用&lt;router-link&gt;标签来声明路由链接，并使用&lt;router-view&gt;标签来声明路由占位符 123456789&lt;template&gt; &lt;div&gt; &lt;h1&gt;App组件&lt;/h1&gt; &lt;!--声明路由连接--&gt; &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/movie\"&gt;电影&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 在router/main.js中导入 并注册组件 12345678910111213// 导入需要被展示的组件import Home from \"@/views/Home.vue\";import About from \"@/views/About.vue\";import Movie from \"@/views/Movie.vue\";const routes = [ // path 是hash地址 component 是要展示的组件 {path: '/home', component: Home}, {path: '/about', component: About}, {path: '/movie', component: Movie}] 路由重定向指的是：用户在访问地址A的时候，强制用户跳转到地址C，从而展示特定的组件页面 用法十分简单 通过路由规则的 redirect属性，指定一个新的路由地址，可以很方便的设置路由的重定向 1234const routes = [// path 表示需要被重定向的“原地址”，redirect表示将要被重定向到的“新地址” {path: '/', redirect: '/home'},] 嵌套路由通过路由实现组件的嵌套展示，叫做嵌套路由 声明 子路由链接和子路由占位符 1234567891011&lt;!-- 在About.vue组件中，声明tab1和tab2的子路由连接以及子路由占位符 --&gt; &lt;div class=\"about\"&gt; &lt;h1&gt;About组件&lt;/h1&gt; &lt;hr&gt; &lt;!-- 声明子路由链接 --&gt; &lt;router-link to=\"/about/tab1\"&gt;tab1&lt;/router-link&gt;&amp;nbsp; &lt;router-link to=\"/about/tab2\"&gt;tab2&lt;/router-link&gt; &lt;hr&gt; &lt;!-- 声明子路由占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; 在父路由规则中，通过 children属性 嵌套声明子路由规则 123456789101112131415161718192021// 导入需要的组件import Tab1 from \"@/views/tab/Table1.vue\";import Tab2 from \"@/views/tab/Table2.vue\";const routes = [ { path: '/about', name: 'About', component: About, // 在嵌套路由中使用路由重定向 redirect:'/about/tab1', children: [ // 通过children属性嵌套子路由规则 {path: 'tab1', component: Tab1}, {path: 'tab2', component: Tab2}, ] }]！！！注意 子路由规则的path 不要以 / 开头 这样写是错误的 children:[{path:'/tab1',component:Tab1}] 路由的query传参 跳转路由并携带query参数 to的字符串写法 1&lt;router-link :to=\"`/home/message/detail?id=${m.id}$title=${m.title}`\"&gt;{{m.title}}&lt;/router-link&gt; 跳转路由并携带query参数 to的对象写法 123456789&lt;router-link :to=\"{ path:'/home/message/detail', query:{ id:m.id, title:m.title }}\"&gt; {{m.title}}&lt;/router-link&gt; 接收参数 12$.route.query.id$.route.query.title 命名路由顾名思义 就是给路由取名字 非常简单 直接加一个name就可以了 作用就是可以简化路由的跳转 使用 1{path: '/about', component: About, name: 'about'}, 简化 1234567891011121314151617&lt;!-- 简化前 需要写完整路劲 --&gt;&lt;router-link to=\"/demo/test/welcome\"&gt;欢迎&lt;/router-link&gt;&lt;!-- 简化后 直接通过名字跳转 --&gt;&lt;router-link to=\"{name:'hello'}\"&gt;欢迎&lt;/router-link&gt;&lt;!-- 检查写法配合传递参数 --&gt;&lt;router-link :to=\"{ name:'hello', query{ id:666, title:'欢迎欢迎', }}\"&gt; 欢迎 &lt;/router-link&gt; 动态路由匹配指的是把Hash地址中可变的部分定义为参数项，从而提高路由规则的复用性。在vue-router中使用英文的冒号:来定义路由的参数项 123&lt;router-link to=\"/movie/1\"&gt;电影1&lt;/router-link&gt; &amp;nbsp;&lt;router-link to=\"/movie/2\"&gt;电影2&lt;/router-link&gt; &amp;nbsp;&lt;router-link to=\"/movie/3\"&gt;电影3&lt;/router-link&gt; &amp;nbsp; 路由中的动态参数以 : 进行声明，冒号后面是动态参数的名称 1{ path: '/movie/:id',name: 'Movie',component: Movie }, 获取动态路由参数值的两种方案 $route.params参数对象 通过动态路由匹配的方式渲染出来的组件中，可以使用$route.params对象访问到动态匹配的参数值 123456&lt;template&gt; &lt;div class=\"movie\"&gt; &lt;!--$route.params 是路由的“参数对象”--&gt; &lt;h1&gt;Movie组件---------{{ $route.params.id }}&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 使用props接收路由参数 为了简化路由参数的获取形式，vue-router允许 路由规则中开启props传参 1234567891011121314// 在movie组件中 以props的形式接收到路由规则匹配到的参数项// 第一种写法，值为对象，该对象中所有的key-value都会以props的形式传给Movie组件 { path: '/movie/:id', name: 'Movie', component: Movie, props: {a:1,b:'hello'} },// 第二种写法，值为布尔值，如果props的值为true 就会把该路由组件收到的所有params参数，以props的形式传给Movie组件 { path: '/movie/:id', name: 'Movie', component: Movie, props: true },// 第三种写法，值为函数props($route){ return {id:$route.query.id,title:$route.query.title}} 12// 在movie组件中使用props接收路由规则中匹配到的参数项 props: ['id'] 12&lt;!-- 直接使用props中接收的路由参数 --&gt; &lt;h1&gt;Movie组件----{{id}}&lt;/h1&gt; 编程式导航通过调用API实现导航的方式，叫做编程式导航，与之对应的，通过点击链接实现导航的方式，叫做声明式导航 普通网页中点击a链接，vue项目中点击router-link都属于声明式导航 普通网页中调用location.href跳转到新页面的方式，属于编程式导航 vue-router中的编程式vue-router提供了许多编程式导航API，其中最常用的两个API分别是 this.$router.push(‘hash地址’) 跳转到指定hash地址，从而展示对应的组件 this.$router.go(数值 n) 实现导航历史的前进，后退 路由守卫路由守卫可以控制路由的访问权限 12345678910111213router.beforeEach((to, form, next) =&gt; { // to 目标路由对象 // from 当前导航正要离开的路由对象 // next 是一个函数 表示放行 const token = localStorage.getItem('token') if (to.path === '/main' &amp;&amp; !token) { // next(false) 不允许跳转 next('/login') //强制跳转到“登录页面” } else { next() // 直接放行， 允许访问“后台主页” }}) 路由器的两种工作模式 hash模式： 地址中永远带着#号 不美观 若以后将地址通过第三方手机app分享，诺app效验严格，则地址会被标记为不合法。 兼容性较好 history模式 地址干净，美观 兼容性和hash模式相比略差 应用部署上线时需要后端人员支持，解决刷新页面服务端404问题","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue-ref引用-作用域插槽","slug":"Vue-ref引用-作用域插槽","date":"2022-04-03T06:21:20.000Z","updated":"2022-04-03T12:21:05.710Z","comments":true,"path":"2022/04/03/Vue-ref引用-作用域插槽/","link":"","permalink":"http://mrnobody233.github.io/2022/04/03/Vue-ref%E5%BC%95%E7%94%A8-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/","excerpt":"","text":"ref引用ref用来辅助开发者在不依赖jQuery的情况下，获取DOM元素或组件的引用 每个vue的组件实例上，都包含一个$refs对象，里面存储着对应的DOM元素或组件的引用。默认情况下，组件的$ref指向一个空对象。 使用 ref 引用 DOM 元素 使用ref属性 为对应的DOM添加引用名称 1&lt;h1 ref=\"myh1\"&gt;App根组件&lt;/h1&gt; 通过 this.$refs.myh1可以获取到DOM元素的引用 操作DOM元素把文本颜色改为红色 1this.$refs.myh1.style.color='red' 使用 ref 引用 组件 实例 使用ref属性 为相对应的组件添加引用名称 1&lt;Counter ref=\"counterRef\"&gt;&lt;/Counter&gt; 通过 this.$refs.counterRef可以引用组件的实例 引用到组件的实例之后，就可以调用组件上的 methods 方法 1this.$refs.counterRef.reset() this.$nextTick(cb)方法 组件的$nextTick(cb)方法，会把cb回调推迟到下一个DOM更新周期之后执行，大概意思就是，等组件的DOM异步的重新渲染完成后，再执行cb回调函数，从而保证cb回调函数可以操作到最新的DOM元素。 123this.$nextTick(()=&gt;{ this.$refs.ipt.focus()}) 插槽插槽(Slot)是vue为组件封装者提供的能力。允许开发者在封装组件时，把不确定的，希望用户指定的部分定义为插槽。 可以把插槽认为是组件封装期间，为用户预留的内容的占位符 基础用法在封装组件时，可以通过&lt;slot&gt;元素定义插槽，从而为用户预留内容占位符 123456789101112&lt;template&gt; &lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--基本用法&lt;/h3&gt; &lt;hr&gt; &lt;p&gt;第一个p标签&lt;/p&gt; &lt;!-- 通过slot标签 为用户预留内容占位符(插槽) --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;p&gt;最后一个p标签&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 用户在使用组件期间 为插槽指定具体内容 1234&lt;MyCom&gt; &lt;!-- 在使用组件时，为插槽指定具体的内容 --&gt; &lt;p&gt;---用户自定义的内容---&lt;/p&gt;&lt;/MyCom&gt; 默认内容封装组件，可以为预留的&lt;slot&gt;插槽提供默认内容。如果组件的使用者没有为插槽提供任何内容，则默认内容会生效 使用方式特别简单，在标签内写上默认内容即可 123456789101112&lt;template&gt; &lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--基本用法&lt;/h3&gt; &lt;hr&gt; &lt;p&gt;第一个p标签&lt;/p&gt; &lt;slot&gt;这是默认内容&lt;/slot&gt; &lt;p&gt;最后一个p标签&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 具名插槽如果在封装组件时需要预留多个插槽节点，则需要为每个&lt;slot&gt;插槽指定具体的 name 名称。这种带有具体名称的插槽叫做”具名插槽” 12345678910111213141516&lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--基本用法&lt;/h3&gt; &lt;hr&gt;&lt;div&gt; &lt;slot name=\"title\"&gt;&lt;/slot&gt;&lt;/div&gt; &lt;div&gt; &lt;main&gt;&lt;/main&gt; &lt;/div&gt; &lt;div&gt; &lt;slot name=\"user\"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/div&gt; 在向具名插槽提供内容的时候，我们可以在&lt;template&gt;元素上使用v-slot,并以v-slot的参数形式提供其名称 123456789&lt;MyCom&gt; &lt;template v-slot:title&gt; &lt;p&gt;鹅鹅鹅&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:user&gt; &lt;p&gt;李白&lt;/p&gt; &lt;/template&gt;&lt;/MyCom&gt; 具名插槽可以简写，(v-slot:)替换为字符#。例如 v-slot:header可以被重写为#header 作用域插槽在封装组件的过程中，可以为预留的&lt;slot&gt;插槽绑定props数据，这种带有props数据的&lt;slot&gt;就是作用域插槽 12345&lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--作用域插槽&lt;/h3&gt; &lt;hr&gt; &lt;slot :info=\"userInfo\" :msg=\"message\"&gt;&lt;/slot&gt;&lt;/div&gt; v-slot:default=”任意合法名” 一般使用scope 接收 接着可以使用插值表达式渲染出来 12345&lt;MyCom&gt; &lt;template #default=\"scope\"&gt; &lt;p&gt;{{ scope.info.name }}&lt;/p&gt; &lt;/template&gt;&lt;/MyCom&gt;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Markor","slug":"Markor","date":"2022-04-02T03:57:05.000Z","updated":"2022-04-02T03:57:52.272Z","comments":true,"path":"2022/04/02/Markor/","link":"","permalink":"http://mrnobody233.github.io/2022/04/02/Markor/","excerpt":"","text":"Markor最近想了一小问题，就是学校解封以后，如果我回家的话基本上是不会碰电脑的，虽然我会把电脑一起带回去，但是基本上都没有打开过，可能是我觉得带着有重量感，不对，是害怕我的github没有保持日常提交代码，所以为了避免这个情况，我可以使用平板来写文档，虽然提交不上去，但是回宿舍以后，我也可以躺在床上用平板来写一写自己想写的东西，这样有挺多好处的，可以避免我在床上玩手机，这样就可以玩平板了，哈哈哈哈哈，为什么想要用平板来写文档呢，写博客什么的都不是最主要的，最重要的是让我的平板键盘能有用武之地，我已经太久没有用我的平板键盘了，一直放在抽屉里积灰，这东西花了我600RMB，我也不知道当时我怎么想的，会买这么贵的东西。 好吧我突然想起来了，在我没有买显示器之前，平板一直是我的副屏，多亏了华为的多屏协同，能帮我省很多事，虽然延迟还是有一小丢丢，但是日常使用还是很给力的，即使是这样还是有缺点的，就是字太小了，我眼睛很好，但是一直看着这么小的字也是会很难受的，所以我买了显示器，果然大屏就是爽，立马抛弃了我的小平板，只用它来记笔记，我们三个一直相处的很好，直到有一天！！！我会写博客了，我为什么不把笔记写在博客里呢，所以我再次抛弃了我的平板，没有考虑平板的感受，呜呜，果然是买前生产力，买后哔哩哔哩，盖泡面，当手托，摸鱼。所以为了改变现状，我可以使用Markor来满足自己突然想写博客的欲望，这一篇博客就是使用Markor来写的，还挺像回事，如果找到更好的软件我还是会替代Markor的，哈哈哈哈哈哈，这样我的平板就不会失宠了。 日常水博客，就酱紫，拜拜。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"}]},{"title":"熬夜之旅","slug":"熬夜之旅","date":"2022-04-01T15:18:55.000Z","updated":"2022-04-01T16:03:25.378Z","comments":true,"path":"2022/04/01/熬夜之旅/","link":"","permalink":"http://mrnobody233.github.io/2022/04/01/%E7%86%AC%E5%A4%9C%E4%B9%8B%E6%97%85/","excerpt":"","text":"熬夜之旅 今天在工作室度过第一个夜晚，虽然在暑假比赛的时候已经住过另一个工作室了，但是这里还是头一次，和我一起的有社恐废宅充电器和胃病患者，比起宿舍我确实更喜欢这里，毕竟这里不需要交电费和水费，最主要的是还有空调可以吹，虽然室友都有比较好的作息时间，但在其他时间还是比较吵的，串门的比较多，所以非常感谢有这么好的环境提供给我学习和休息，今晚如果没有SB抢我的折叠床，我应该会睡的比较早。 其他的事 凌晨两点半的时候，有一个网友突然发现了我，她问我是谁，毕竟隔了四五年了，不记得我是谁也很正常，所以我稍微和她解释了一下，这样体现了给人写备注的好处。这个姑娘的也挺悲催的，所以我对她印象挺深刻，她和父母关系不好，有自残倾向，到了现在和她聊了一会，她告诉我在今年，也就是她的18岁那天，她自杀未遂，但是和父母关系好了一些，她说她重生了，我为她感到高兴，但也不敢问的太仔细，虽然她貌似想向我分享那些事情，但我还是把话题给往其他地方给放了，认识她是在一个仓鼠群里，我以前养过仓鼠，和她聊得比较好所以她加了我，并且告诉我她家里的一些事，当时我并不会安慰人，只是默默听着，让她有一个地方可以宣泄自己的压力，虽然现在也是一样，我还是不会安慰人，能感受的到别人悲伤的情绪，但也不会说什么，还可能会逃避。 扯多了，她问我怕蛇吗，我没回答，只是问她现在开始养蛇了嘛，和仓鼠放在一起不会出事吗，以及蛇没有咬过你吗，她说没有，倒是很想被咬一下试试，所以一不小心又回到了自残的话题，说自己又开始抽起了烟，本以为能缓解压力，结果压力更大了，每天晚上睡眠时间只有5小时，离她想上的大学平均分还差2分，也就是每科需要进步十分，我不敢多聊，因为太晚了，已经快凌晨3点了，所以告诉她生活的美好，以及还有很多没有碰到过的有意思的事情之类的，接着就睡了。 其实像这样的网友还有很多，以前聊的特别欢乐，突然有一天就没继续下去，也不知道是什么时候结束，但还是保存在自己的联系人里，默默的看着他们的变化，也是一种属于我自己的乐趣， 最后注意身体，不要熬夜现在是2022年4月2日00:00:57，虽然标题是熬夜之旅，实际上是我想不出标题的名字而已，就酱紫，如果我再不睡，我的折叠床就要被傻逼玷污了！就酱紫，掰掰。还有一件事，这个标签是自言自语，看看就行了，全当我放屁，掰掰。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"}]},{"title":"Vue组件和props","slug":"Vue组件和props","date":"2022-04-01T06:50:11.000Z","updated":"2022-04-03T08:07:17.211Z","comments":true,"path":"2022/04/01/Vue组件和props/","link":"","permalink":"http://mrnobody233.github.io/2022/04/01/Vue%E7%BB%84%E4%BB%B6%E5%92%8Cprops/","excerpt":"","text":"组件组件之间可以相互引用，首先得注册后使用 如何注册注册组件的方式分为两种，全局注册 和 局部注册 被全局注册的组件，可以在全局任何一个组件内使用/ 被局部注册的组件，只能在当前注册的范围内使用 全局注册组件 在main.js 中导入需要被全局注册 的组件 1import Count from \"@/components/Count.vue\"; 调用Vue.component()方法全局注册组件 1Vue.component('Count', Count) 在app组件中使用Count组件 1&lt;Count&gt;&lt;/Count&gt; 局部注册组件 在app.vue中导入需要被局部注册的组件 1import Count from \"@/components/Count.vue\"; 在components节点下通过键值对的方式注册组件 123components: { 'Count': Count,} 在app组件中使用Count组件 1&lt;Count&gt;&lt;/Count&gt; 全局注册和局部注册的区别 被全局注册的组件，可以在全局任何一个组件内使用 被局部注册的组件，只能在当前注册的方位内使用 组件的propsprops是组件的自定义属性，组件的使用者可以通过props把数据传递到子组件内部，供子组件内部进行使用。 作用：父组件通过props向子组件传递要展示的数据 好处：提高了组件的复用性 如何声明props在封装Vue组件时，可以把动态的数据项作为props自定义属性。自定义属性可以在当前组件的模板结构中被直接使用。 在子组件中声明两个要使用的props数据 比如向外界传递一个标题，作者 可以声明一个props数组 外界可以传递指定的数据，到当前的组件中1props:['title','author'] 然后可以在DOM结构中使用title的值和author的值，使用插值表达式{{}} 将两个值渲染到里面 123456&lt;div&gt; Article组件 &lt;h3&gt;标题：{{ title }}&lt;/h3&gt; &lt;h3&gt;作者:{{ author }}&lt;/h3&gt; 抽刀断水水更流，举杯消愁愁更愁&lt;/div&gt; 接着在使用这个组件期间，可以传递两个数据的值 1&lt;Article title=\"鹅鹅鹅\" author=\"木子日天\"&gt;&lt;/Article&gt; 也可以使用v-bind属性绑定的形式，为组件动态绑定props的值 1&lt;Article :title=\"info.title\" :author=\"info.name\"&gt;&lt;/Article&gt; props验证 指的是：在封装组件时对外界传递过来的props数据进行合法性的效验，从而防止数据不合法的问题。 使用数组类型props节点的话，无法为每个props指定具体的数据类型 对象类型的props节点 使用对象类型的props节点，可以对每个props 进行数据类型的效验 对象类型的props节点，提供了多种数据验证方案 基础的类型检查 1234 props:{ // title的属性值只能是数字类型 title:Number,} 多个可能的类型 1234 props:{ // title的属性值可以是 \"字符串\" 或者 \"数字\" title:[String,Number],} 必填项效验 123456 props:{ title:{ type:String, // 表示当前属性的值必须是String字符串类型 required:true // 表示当前属性是 }} 属性默认值 123456 props:{ age:{ type:Number, // 表示当前属性的值必须是String字符串类型 default:18, // 如果有使用者没有指定 age 的值 则它的默认值为18 }} 自定义验证函数 动态组件指的是动态的切换组件的显示与隐藏。vue提供了一个内置的&lt;component&gt;组件，专门用来实现组件的动态渲染。 &lt;component&gt; 是组件的占位符 通过 is属性 动态指定 要渲染的组件名称 &lt;component is=\"要渲染的组件的名称\"&gt;&lt;/component&gt; 使用keep-alive 保持这状态默认情况下，切换动态组件时无法保持组件的状态。这样就可以使用 &lt;keep-alive&gt;组件保持动态组件的状态 使用方式非常简单 123&lt;keep-alive&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"不要熬夜","slug":"不要熬夜","date":"2022-03-28T14:31:41.000Z","updated":"2022-03-29T02:18:45.328Z","comments":true,"path":"2022/03/28/不要熬夜/","link":"","permalink":"http://mrnobody233.github.io/2022/03/28/%E4%B8%8D%E8%A6%81%E7%86%AC%E5%A4%9C/","excerpt":"","text":"熬夜 起因昨天和工作室的小伙伴们一起看社恐废宅充电器在玩一款新的游戏，叫做幽灵线: 东京，我们更喜欢叫他林正英模拟器 对了那个游戏长这样确实比较新颖，因为他的攻击方式是把手比作枪，用手射出子弹一样，给人眼前一亮的感觉，但是玩久了感觉有点单调，不算很耐玩的游戏，也许是它太贵了我买不起，要200多RMB。 然后我们的社恐废宅充电器就开始了今天的熬夜，他花了一晚上的时间通关了幽灵线: 东京，虽然是简单版的模式，但主要的是他通宵到到第二天中午才开始睡觉，这是他的睡姿 睡得和死了一样，这样的情况已经不是第一次了，我们也不是第一次提醒他，所以这里提前说明一下，如果他突然有一天走着走着就猝死了，希望他不要来找我，因为我已经提醒了很多次了， 接着在寒假的时候我也熬夜，但是没有他这么严重，最多熬到四五点，偶尔六点多起来去吃早餐，我记得五点半去的时候老板娘还没有准备好，所以我等到六点在去吃的，挖槽，原来早饭这么好吃，特别是那个猪血粉，等学校解封我回我奶奶家，一定得再去吃一次，现在想起来那个老板娘还是我小学同学的妈妈，她告诉我她女儿去参军了，两年以后才会回来，我倒是挺期待她能被改变成什么样，但是我最希望的是老板娘能送我瓶核桃味的早餐奶给我喝，我太喜欢喝了，噗哈哈。 最后额，今天写的这个主要是做了一个新的分类，叫做自言自语，其目的是为了水博客，和分享关于自己有意思的事情，又或者是把自己可能会忘记的日常存在这里，所以最后还是点名一下主题把，就是希望我以后能少熬点夜，不能和那个SB一样，就当为了吃到好吃的猪血粉而努力吧，就这样，晚安~","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"}]},{"title":"实用网站","slug":"实用网站","date":"2022-03-26T13:19:12.000Z","updated":"2022-04-15T04:41:27.865Z","comments":true,"path":"2022/03/26/实用网站/","link":"","permalink":"http://mrnobody233.github.io/2022/03/26/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99/","excerpt":"","text":"实用网站我的文件夹里有许多使用的网站，但也只是放在文件夹里，乱七八糟，没有整理，所以现在放在这里，以后就可以更加方便的利用这些网站 编程类颜色网站 不知道如何配色可以看看介个网站 另一个颜色网站 这个也不错 取名鬼才不知道取什么变量名可以看看这个 阿里字库不管是网页还是PS，又或者是PPT，都可以用得上，真不错 图片类wallpaper壁纸 有许多挺不错的漂亮壁纸可以在这里看 搜图神器 可以搜索超清的好康的图片 主要我是荣耀捐赠会员 音乐类刘志进音乐直连搜索 可以在这里搜索很多音乐 外链转换工具 可以配合上一个网站获得音乐的mp3网址 影视类hwj影视 可以看各种电影和番剧 (使用手机打开会有广告，推荐打开网页版 ) 寻剧吧 也是看各种电影和番剧 (使用手机打开会有广告，推荐打开网页版 ) 蜀黍的网站 你所热爱的就是你的生活 (陈睿 吃柠檬) 油管 可以在里面找乐子0.0 要翻墙 娱乐类今天吃什么 不知道吃什么可以看看介个 Picrew 随机生成头像，我的github的头像就是这里来的，是不是很好看 qwq 要翻墙 逗比拯救世界 很多各种各样的表情包，逗比必备哦。 其他免费空间 学习html css的时候跟着pink老师找到网站。 木子网 上传的大一下学期的期末作业，纯html和css，做的好像比现在还好看许多，果然我把css忘光了。 查看综测分 查看综测分 学校选课 学校选修网课 ## 无聊了继续更新 拜拜","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"网站","slug":"网站","permalink":"http://mrnobody233.github.io/tags/%E7%BD%91%E7%AB%99/"},{"name":"工具","slug":"工具","permalink":"http://mrnobody233.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Vue指令","slug":"Vue指令","date":"2022-03-26T09:33:02.000Z","updated":"2022-03-26T11:19:52.738Z","comments":true,"path":"2022/03/26/Vue指令/","link":"","permalink":"http://mrnobody233.github.io/2022/03/26/Vue%E6%8C%87%E4%BB%A4/","excerpt":"","text":"Vue指令 虽然学习完了Vue，但还有许多地方木有掌握，所以今天就来复习一下Vue还没有掌握的指令 按键修饰符 条件渲染指令 循环渲染指令 虽然只有一些内容，但还是要认真的写下去，不然就得去平板看我写的丑不拉几的字，我实在不忍心看下去，这也是在这里复习的原因之一。 按键修饰符 在监听键盘事件的时候，我们需要判断详细的按键，此时，可以为键盘相关的事件添加按键修饰符 举一个非常简单的案例，当我们在登录页面输入完密码之后，按下回车键后使用Ajax发送数据 如何实现捏？ 我们可以使用 @keyup事件 &lt;input type=\"password\" @keyup.enter=\"commitAjax\"&gt; 这样在input表单中按下回车键就可以触发方法了 非常的方便，学废了。 条件渲染指令这个好像挺简单的，既然打出来了，全当复习用了这个东西主要用来辅助开发者按需控制DOM的显示与隐藏但是条件渲染指令有两个 v-if v-show 两者区别不大 但还是要讲一讲 继续举一个简单地例子 123&lt;p v-if=\"flag\"&gt;这是被 v-if 控制的元素&lt;/p&gt;&lt;!-- -------当flag为false的时候两者都会隐藏 但是隐藏的方法不一样-------- --&gt;&lt;p v-show=\"flag\"&gt;这是被 v-show 控制的元素&lt;/p&gt; v-if 会动态创建元素或者移除v-show 则是给元素添加 display:none;样式 来实现元素的显示和隐藏 差点忘记了还有一个 v-else v-else指令必须搭配 v-if 来进行使用 否则将不会被识别 来看个简单地例子就会了 1234&lt;div v-if=\"type === 'A'\"&gt;优秀&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt;良好&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt;一般&lt;/div&gt;&lt;div v-else&gt;差&lt;/div&gt; 是不是很简单呢 循环渲染指令实际上这个才是我要复习的内容，前面两个都太简单了，虽然这个也是，看看文档就会了，但是为了以后不用看文档，所以才认真写一写吧 V-for列表渲染指令，用于开发者基于一个数组来循环渲染一个列表结构 先来看看代码 12345678data:{ // 列表数据 list[ {id: 1 ,name: '木子日天' }, {id: 2 ,name: '李日天' }, {id: 3 ,name: '木子昊' }, ]} 要循环那个DOM 就给那个加上 v-for=\"item in list\" 1234&lt;div v-for='item in list'&gt; &lt;p&gt;{{item.id}} ,{{item.name}}&lt;/p&gt;&lt;/div&gt; item 是循环的每一项list是被循环的数组 结果就是 1231,木子日天2,李日天3,木子昊 使用了v-for指定那么一定要绑定一个 :key属性 123&lt;div v-for=\"item in list\" :key=\"item.id\"&gt; &lt;p&gt;{{item.id}} ,{{item.name}}&lt;/p&gt;&lt;/div&gt; 就酱紫 拜拜","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"First_Vue_Web","slug":"First-Vue-Web","date":"2022-03-25T10:45:09.000Z","updated":"2022-03-26T09:11:36.909Z","comments":true,"path":"2022/03/25/First-Vue-Web/","link":"","permalink":"http://mrnobody233.github.io/2022/03/25/First-Vue-Web/","excerpt":"","text":"原因因为我的同学胃病患者在上学期参加了，信工的移动安卓设计比赛，并获得了二等奖，我很是心动 ，并不是心动二等奖，而是心动因为二等奖获得的雷蛇鼠标，虽然我已经买了一个比他更贵的鼠标，但是我好不爽，能白嫖为什么要买，所以我下定决心，去参加了这个学期的网站设计大赛，获得更高的奖品，至少给我一个雷蛇键盘 想法正好最近学完Vue,有用武之地，为了不让知识悄悄溜走，所以我决定使用Vue来制作本次项目，询问了举办方老师，可以使用Vue之类的东东，所以很快啊，我立马新建文件夹，可是不知道做什么类型的东西，思考许久，终于！！ 我决定做一个做烂的东西，也就是我们工作室的网站，但是是SPA（单页应用程序），想法有了，就有动力去做了。正好比赛需要上交一份PPT，也就顺便把SPA的介绍在博客里面写好，这样就不用再去百度了，我真聪明，哈哈哈哈哈哈！。 SPA（单页面应用程序）1.什么是单页面应用程序单页面应用程序 （英文名:Single Page Application）简称SPA，顾名思义，指的就是一个Web网站中只有唯一一个HTML页面，所有的功能和交互都在这唯一的一个页面内完成 2.单页面应用程序的特点单页面应用程序将所有的功能局限于一个web页面中。仅在该web页面初始化时加载相应的资源（HTML，JavaScript，CSS） 一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转。而是利用JavaScript动态的变换HTML内容，从而实现用户的交互。 3.单页应用程序的优点良好的交互体验 单页面应用的内容的改变不需要重新加载整个页面 获取数据也是通过Ajax异步获取 没有页面之间的跳转，所以不会出现“白屏现象” 良好的前后端工作分离模式 后端专注于提供API接口，更容易实现API接口的附庸 前端专注于页面的渲染，更利于前端工程化的发展 减轻服务器的压力 服务器只需提供数据，不负责页面的合成与逻辑的处理，吞吐能力会提高几倍。 4.单页应用程序的缺点 1.首屏加载慢 2.不利于SEO 长啥样？ 说了这么久那么做的到底咋样呢？实际上不怎么地，在制作期间参考了许多网站，包括学长写过的工作室网站发现我写的实在是太垃圾了，简直就是一坨屎一样，不过好歹是我第一次完成Vue作品，也使用了大量的Vant组件和Element组件，整体看起来不算很丑（自我安慰），相信我以后技术成熟了能够更加完善这个项目，不用再参考公众号的布局。哈哈，那么就来看一看吧。 长这样。 这样。 和这样 没有全截完 但是也可以看出 制作水平很一般了。 所以还需再接再厉。拜拜~","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://mrnobody233.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"不要被外表迷惑","slug":"不要被外表迷惑","date":"2022-03-25T05:30:58.000Z","updated":"2022-03-28T14:32:39.482Z","comments":true,"path":"2022/03/25/不要被外表迷惑/","link":"","permalink":"http://mrnobody233.github.io/2022/03/25/%E4%B8%8D%E8%A6%81%E8%A2%AB%E5%A4%96%E8%A1%A8%E8%BF%B7%E6%83%91/","excerpt":"","text":"本来这个博客很早就可以完成的，都怪我被迷惑了，因为那个网站实在是太漂亮了，我也想整一个 就是这个网站(可以点我)，他实在是太漂亮了，原来网站可以这么漂亮,所以我决定使用这个网站，但是发现他的配置文件完全看不懂，我实在是太菜了。 感觉自己白学前端了，所以我下定决心，毕业以后一定不要做程序员 还是去送外卖好了QWQ,所以今天我学废了，自己垃圾就不要去看大佬作品，否则会怀疑人生，马上自闭。 就酱紫，拜拜~~","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"}]}],"categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"},{"name":"网站","slug":"网站","permalink":"http://mrnobody233.github.io/tags/%E7%BD%91%E7%AB%99/"},{"name":"工具","slug":"工具","permalink":"http://mrnobody233.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"项目","slug":"项目","permalink":"http://mrnobody233.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]}