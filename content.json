{"meta":{"title":"MrNobody's Blog","subtitle":"保持呼吸 不要断气","description":"MrNobody","author":"Mr_Nobody","url":"http://mrnobody233.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-03-25T12:46:37.000Z","updated":"2022-03-25T12:46:55.821Z","comments":true,"path":"categories/index.html","permalink":"http://mrnobody233.github.io/categories/","excerpt":"","text":""},{"title":"","date":"2022-04-23T15:29:03.408Z","updated":"2022-04-23T15:29:03.408Z","comments":true,"path":"about/index.html","permalink":"http://mrnobody233.github.io/about/","excerpt":"","text":"关于为什么会有这个博客，因为我写的第一个Vue项目里面想添加一个友情链接，跳转到我的个人博客，但是我并没有博客，所以我从今天，也就是2022年3月25日13:39:38 诞生了我的第一个博客。 虽然这个博客的主题很漂亮，叫做Diaspora，但是我写不出来，我太菜了，也许有朝一日我能写出属于自己主题的博客 介绍我叫木子曰天，我今年好多岁了，我是个男孩子，马上就要大三了，还是一个什么都不会的垃圾。 如果想要找垃圾玩，可以坐火车到南昌西站，在坐地铁一号线到双港，最后拨打我的电话就行。我性格古怪，脏话连篇，看到熟人会对他放屁，看到我可以立马跑掉,我的QQ是,最好是加我的telegram PS:需要翻墙 技能点 1.我亚索很厉害 2.CSGO摆烂很厉害 3.会一些web前端 4.可以像猴子一样到处乱爬 5.骂人很厉害 6.掐人很痛 7.放屁很臭 8.鼻屎攻击 9.阴阳怪气 10.别人在我面前我可以把他帅死 11.取名鬼才(详细可查看下方友情链接) 好友的博客 (点击头像放大，点击姓名可查看对方博客) @butterflyFish @果果超甜 @胃病患者 @社恐废宅充电器"},{"title":"search","date":"2022-03-26T13:09:20.000Z","updated":"2022-03-26T13:10:30.800Z","comments":true,"path":"search/index.html","permalink":"http://mrnobody233.github.io/search/","excerpt":"","text":""},{"title":"tags","date":"2022-03-25T12:47:43.000Z","updated":"2022-03-25T12:47:59.970Z","comments":true,"path":"tags/index.html","permalink":"http://mrnobody233.github.io/tags/","excerpt":"","text":""}],"posts":[{"title":"Vue3-常用CompositionAPi","slug":"Vue3-常用CompositionAPi","date":"2022-05-03T13:38:41.000Z","updated":"2022-05-05T03:41:09.780Z","comments":true,"path":"2022/05/03/Vue3-常用CompositionAPi/","link":"","permalink":"http://mrnobody233.github.io/2022/05/03/Vue3-%E5%B8%B8%E7%94%A8CompositionAPi/","excerpt":"","text":"setup vue3中的一个新的配置项，值为一个函数 组件中所用到的：数据，方法等等，均要配置在 setup 中 setup 函数的两种返回值： 若返回一个对象，则对象中的属性，方法，在模板中均可以直接使用。 若返回一个渲染函数：则可以自定义渲染内容 ref函数 作用：定义一个响应式的数据 语法: const name = ref('zs') 创建一个包含响应式数据的引用对象（reference对象 简称ref对象） js中操作数据：name.value 模板中读取数据： 不需要.value, 直接&lt;div&gt;{{ name }}&lt;/div&gt;12345678910111213141516171819202122232425262728293031323334353637383940414243 &lt;template&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;姓名：{{ name }}&lt;/h1&gt; &lt;h1&gt;年龄：{{ age }}&lt;/h1&gt; &lt;h1&gt;工作种类：{{ job.type }}&lt;/h1&gt; &lt;h1&gt;工资：{{ job.money }}&lt;/h1&gt; &lt;button @click=\"changeInfo\"&gt;修改人的信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 导入refimport {ref} from 'vue'export default { name: \"App\", setup() { let name = ref('zs') let age = ref(18) let job = ref({ type: '前端', money: 3000 }) function changeInfo() { name.value = 'ls' age.value = 48 job.value.type = '后端' job.value.money = 4000 console.log(name, age) } return { name, age, changeInfo, job } }}&lt;/script&gt; reactive 函数 作用：定义一个对象类型的响应数据(基本类型不要用它，要用ref函数) 语法：const person = reactive({ name:'zs', age:18 }),接收一个对象 (或者数组)返回一个代理对象(proxy对象) reactive 定义的响应式数据是 “深层次的” 内部基于ES6的Proxy实现，通过代理对象操作对象内部数据进行操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div class=\"container\"&gt; &lt;h1&gt;姓名：{{ person.name }}&lt;/h1&gt; &lt;h1&gt;年龄：{{ person.age }}&lt;/h1&gt; &lt;h1&gt;工作种类：{{ person.job.type }}&lt;/h1&gt; &lt;h1&gt;工资：{{ person.job.money }}&lt;/h1&gt; &lt;h1&gt;爱好：{{ person.hobby }}&lt;/h1&gt; &lt;button @click=\"changeInfo\"&gt;修改人的信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import {reactive} from 'vue'export default { name: \"App\", setup() { // 数据 let person = reactive({ name: 'zs', age: 18, job: { type: '前端', money: 3000 }, hobby: ['抽烟', '喝酒', '烫头'] }) // 方法 function changeInfo() { person.age = 48 person.job.type = '后端' person.job.money = 4000 person.hobby[0] = '放屁' console.log(person.name, person.job.type) } return { person, changeInfo, } }}&lt;/script&gt; reactive 对比 ref 从定义数据角度对比： ref 用来定义： 基本类型数据 reactive 用来定义 对象(或数组) 类型数据 备注： ref 也可以用来定义对象(或数组) 类型数据，它内部会通过reactive转为代理对象 从使用角度对比 ref 定义数据：操作数据需要.value,读取数据时模板中直接读取,不需要.value reactive 定义数据：操作数据与读取数据：均不需要 .value 计算属性与监视1.computed函数 与Vue2中computed配置功能一致 写法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; 姓：&lt;input type=\"text\" name=\"\" id=\"\" v-model=\"person.firstName\"&gt; &lt;br&gt; 名：&lt;input type=\"text\" name=\"\" v-model=\"person.lastName\"&gt; &lt;br&gt; &lt;span&gt;全名：{{ person.fullName }}&lt;/span&gt; &lt;br&gt; 全名：&lt;input type=\"text\" v-model=\"person.fullName\"&gt;&lt;/template&gt;&lt;script&gt;import {reactive, computed} from \"vue\";export default { name: \"App\", setup() { // 数据 let person = reactive({ firstName: \"张\", lastName: \"三\" }) // 计算属性--简写形式 (没有考虑计算属性被修改的情况) /* person.fullName = computed(() =&gt; { return person.firstName + \"-\" + person.lastName }) */ // 计算属性--完整写法 (考虑读和写) person.fullName = computed({ get() { return person.firstName + \"-\" + person.lastName }, set(value) { const nameArr = value.split('-') person.firstName = nameArr[0] person.lastName = nameArr[1] } }) return { person, } }}&lt;/script&gt; watch函数 与Vue2 watch配置功能一致 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;h2&gt;当前求和为：{{ sum }}&lt;/h2&gt; &lt;button @click='sum++'&gt;+1&lt;/button&gt; &lt;hr&gt; &lt;h2&gt; 当前的信息为：{{ msg }}&lt;/h2&gt; &lt;button @click=\"msg+='!'\"&gt;修改信息&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import {ref, watch} from \"vue\";export default { name: \"App\", setup() { // 数据 let sum = ref(0) let msg = ref('你好吗') // 情况1： 监视ref所定义的一个响应式数据 /* watch(sum, (newValue, oldValue) =&gt; { console.log('sum变了', newValue, oldValue) }, {immediate: true, deep: true}) */ // 情况2： 监视ref所定义的多个响应式数据 watch([sum, msg], (newValue, oldValue) =&gt; { console.log('sum 或 msg 变了', newValue, oldValue) }, {immediate: true, deep: true}) return { sum, msg } }}&lt;/script&gt; watchEffect 函数 不用指明监视哪个属性，监视的回调中用到哪个属性，就监视哪个属性 类似computed： computed注重计算出的值（回调函数的返回值），所以必须要写返回值 watchEffect更注重的是过程 （回调函数的函数体），所以不用写返回值 12345678// watchEffect 所指定的回调中用到的数据只要发生变化，就会直接重新执行回调import { watchEffect } from 'vue'watch(()=&gt;{ const x1 = sum.value console.log('watchEffect配置的回调执行了')})","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"浅度睡眠","slug":"浅度睡眠","date":"2022-04-25T15:16:45.000Z","updated":"2022-04-26T02:03:08.481Z","comments":true,"path":"2022/04/25/浅度睡眠/","link":"","permalink":"http://mrnobody233.github.io/2022/04/25/%E6%B5%85%E5%BA%A6%E7%9D%A1%E7%9C%A0/","excerpt":"","text":"羽毛球昨天下午和ButterflyFish，废宅充电器，胃病患者，还有果果超甜以及他的室友一起去打室内羽毛球，虽然平均每人六块钱，实际上体验还是非常不错的，就是没有空调。我和ButterflyFish一组，一开始对战的是果果超甜和他的室友，胃病患者则是和充电器一组。太久没有运动果然非常吃力，由于ButterflyFish的运动细胞实在是太差了，加上她并不会打羽毛球，所以相当于是我一个人打他们两个人，本来是不打算带ButterflyFish一起打的，这样他们就不会认真打，考虑到有个萌新就会有所限制，还好差一个人，果然一起打球还是很开心的，等有时间了天气好了我一定好好教她怎么发球和接球。 虽然ButterflyFish并不会打球，好在我技高一筹，我滴发球实在是太变态了，打的非常阴间，靠着发球得分我和ButterflyFish击败了他们两个，接下来是胃病患者和充电器，因为我的体力不支，很快便败下阵来。实在是太虚了！！还没几下就不行了，不过这也不能完全怪我（试图安慰自己），连续好几早上六点起来做核酸八点钟又要上课，因为睡眠不足才导致的体力下降，就是酱紫！要不是因为没蓝了，不然我就开始暴打胃病患者，脚踢废宅充电器。结束之后我和果果超甜一起回他宿舍洗澡，因为我寝室的热水器坏了呜呜呜，厕所有灯的感觉真滴太好了，不知道我们寝室什么时候会把热水器修好。 浅度睡眠因为太累了所以今天的睡眠质量非常高，能感觉到浑身充满了力量，已经很久没有这么有精神过了，所以我做完核酸后睡到十点半就去工作室了，哈哈哈哈。我的睡眠质量实在是太垃圾啦，基本上每天都是浅睡，关于为什么这样其实我心里还是有点b数的，首先是手机，玩着玩着就忘记了时间，接着是睡眠环境，只要有一点风吹草动我就睡不着，更何况寝室还有一个打呼噜的室友，最重要的是胡思乱想，哪来那么多东西给我想，每天都要睡觉，每天都要胡思乱想。上到国家政治大事，下到身边琐事。我想的东西跨度有点大，打个比方吧。 比如我想着学校解封以后去吃牛蛙，然后联想到疫情，接着联想到国家如何防控疫情，然后是国外想要与新冠病毒共存，只要它一直共存，我们这里就永远不会清零，奶奶滴，实在是太可恶了。我玩瘟疫公司都打不过人类，他们实在是太团结了，只要有一个国家做好解药就会用飞机运送到各个国家，相互帮助。然而现实是不一样，游戏中国家没有勾心斗角，现实会有，然后联想到这个sb游戏在一些版本中把我们国家地图缺少一部分，少了台湾和香港，并且把蒙古国给合并在中国。然后思维跳跃，直接回到幼儿园，回想起我妈妈给我做炸香蕉吃，太好吃了，用面粉包裹，然后粘上白糖，人间美味啊，然后是小学大晚上和我堂妹跑到隔壁财经大学看别人放孔明灯，结果玩太晚了回去被我婶婶给骂了，骂了以后给我和堂妹一人一瓶泡在热水里的旺仔牛奶，可是太久了已经变温了，骂的我和我堂妹畏畏缩缩的去睡觉了。又跳回到现在，原来我上了大学才知道家附近的财经大学是一本，小时候可以随便进出，长大了却进不去，呜呜呜，马上就要大三了，结果专升本还是得考本校，而且还可能考不上，那我考不上可以提前去打工吗，这样我就可以提前赚小钱，本来暑假可以去舅舅公司实习的，可是疫情又严重了被困在学校里快逼疯了。大部分学校的学生居然因为疫情不能出校而通过跳广场舞来解闷，那学校里面有疫情怎么办，只是有时候会看到保安骑着电动车叫没有戴口罩的学生带好口罩而已，看到保安我又想起上学期纳新的时候我们社团的帐篷被别人偷走了，然后去保卫处调监控，写笔录，我和胃病患者一起去的，结果是那一条路居然没有监控，我真滴服了，因为没有监控他们也懒得帮我们找，后来才看见被某社团替换了他们坏掉的帐篷，丢在了后面，真滴太恶心了。 就是这样每天胡思乱想，从一件事联想到另一件事，没完没了才导致我的体质降低，影响我的学习，健康，寿命，通过昨天打羽毛球我才发现好像并不是我睡不着，而是我不够累，看来我得每天和果果超甜一起去跑跑步，这样我就可以睡好觉了，也许吧，，，想我这样的人应该去写小说，可惜我的文笔实在是太垃了，写博客用的都是大白话。得多去看看书，不然人家用高级语言骂我都不知道，正好我被充电器推荐买了《一九八四》《我们》《美丽新世界》，因为是上海的出版社，所以我付款后到现在还没有发货，这些好像都不是问题，因为ButterflyFish的《仿生人会梦见电子羊吗？》我还没有看完，这就是我唯一担心的问题，我能不能静下心来把一本书看完，实际上是可以的，在20年的暑假我看完了《麦田里的守望者》所以我相信我还是能够把那些书看完滴，嘿嘿，就这样吧平板打字太累了，掰掰。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"},{"name":"周记","slug":"周记","permalink":"http://mrnobody233.github.io/tags/%E5%91%A8%E8%AE%B0/"}]},{"title":"axios拦截器","slug":"axios拦截器","date":"2022-04-24T12:45:28.000Z","updated":"2022-04-24T13:46:58.136Z","comments":true,"path":"2022/04/24/axios拦截器/","link":"","permalink":"http://mrnobody233.github.io/2022/04/24/axios%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"","text":"拦截器拦截器 (英文：interceptors) 会在每次发起ajax请求 和得到响应 的时候自动被触发 应用场景： Token 身份认证 Loading 效果 etc… 配置请求拦截器通过 axios.interceptors.request .use( 成功的回调，失败的回调) 可以配置请求拦截器，其中失败的回调函数可以被省略！ 123456789axios.interceptors.request.use((config)=&gt;{ // 一定要 return config 固定写法 return config;},(error)=&gt;{ return Promise.reject(error);}) 请求拦截器-Token 认证12345678910111213141516// 1.导入axiosimport axios from \"axios\";// 2.设置请求的根路径axios.defaults.baseURL = 'http://127.0.0.1:8888/api/private/v1/'// 配置请求拦截器axios.interceptors.request.use(config =&gt; { // 为当前请求配置 Token 认证字段 config.headers.Authorzation = 'bear xxx' console.log(config) return config})// 3.把包挂载到vue的原型对象上Vue.prototype.$http = axios 展示 Loading 效果借助 element ui 提供的 Loading 效果组件 可以方便的实现Loading效果展示 12345678910111213// 1.按需导入Loading效果组件import { Loading } from 'element-ui'// 2.声明变量，用来存储 Loading 组件的实例对象let loadingInstance = null// 配置请求拦截器axios.interceptors.request.use(config =&gt; { // 调用 Loading 组件的 service() 方法,创建 Loading 组件的实例，并全屏展示 loading 效果 loadingInstance = Loading.service({fullscreen: true}) return config}) 配置响应拦截器通过 axios.interceptors.response .use( 成功的回调，失败的回调) 可以配置响应拦截器，失败的回调函数依旧可以被省略。 123456789axios.interceptors.response.use((response)=&gt;{ return response;},(error)=&gt;{ return Promise.reject(error);}) 响应拦截器 - 关闭Loading效果调用 Loading 实例提供的 close() 方法即可关闭 Loading效果 123456// 配置响应拦截器axios.interceptors.response.use(response =&gt; { // 关闭loading loadingInstance.close() return response})","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Ajax","slug":"Ajax","permalink":"http://mrnobody233.github.io/tags/Ajax/"}]},{"title":"第一次拆机","slug":"第一次拆机","date":"2022-04-23T15:30:17.000Z","updated":"2022-04-23T16:15:44.480Z","comments":true,"path":"2022/04/23/第一次拆机/","link":"","permalink":"http://mrnobody233.github.io/2022/04/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8B%86%E6%9C%BA/","excerpt":"","text":"周记创建了一个新的标签 叫做周记 和日记差不多，不过是换成了一周一次，又或者是好几周一次，所以取名为周记， 起因昨天充电器把apex传给我了，安装好以后确实能玩，把所有配置降到最低以后还是卡的一批，充电器检查后找到了一些原因，就是我的电脑太辣鸡啦，除了写代码一无是处，还有一些原因是我的电脑买了快两年了，散热器积灰了，风都出不来了，从而导致的帧数降低，为了让我更好的使用这台 华为 matebook13 2020 办公本，来玩 apex 和 CSGO 带充电器 上大分，他今天中午带了螺丝刀准备帮我拆机清理灰尘，说实话我还是非常担心的。 回忆在19年的时候我也尝试过自己拆机，不过拆的是我的手机，我心爱的 小米mix2s 因为它打游戏的续航能力实在是太垃圾了啦，玩两局吃鸡就基本没电了，所以我买了它的4500毫安的电池，准备给它换一个新的心脏。经历了九九八十一难，我终于把它的后盖打开了，一切都准备就绪，可是我弄错了一根线，以为它是电源线，实际上它是前置摄像头的线，用力一拔下后，断了。。。当时我心都凉了一大截，在一瞬间我买什么手机都想好了，后来长按开机后才发现是前置摄像头，吓屎我了，差点就要换手机了。嘿嘿，虽然不能拍我的美照了，但是游戏续航提升了一大截，缺点就是充电慢了许多。 拆机经历了那件事后，我对拆机有了一些莫名的恐惧感，生怕拆断一根线，但是现在是充电器来帮我拆，即使是这样我还是会非常担心滴，毕竟我没有更多的钱买新的电脑了。在拆完外面六个螺丝之后，准备打开后盖，我差点要暴力拆开后壳了，还好充电器叫我看一下拆机视频，结果发现垫子底下居然藏了四个螺丝，妈的差点外壳就要报废了。所以需要回到我宿舍使用吹风机把垫子里面的胶吹化掉然后拿下来。回宿舍期间我给充电器买了个 1.5￥ 的冰棒作为报酬。拆完垫子之后回到工作室，终于看到了我心爱的电脑的内脏，长这样子。 可见灰尘还是蛮多的，接下来就看充电器的操作了，不愧是老手，在拆机之前居然双手摸桌子下的铁柱子，来释放人体电流，防止电脑触电烧机，实在是太高级了！在他的努力下，我的电脑居然安然无恙，正常开机了，而且还抹了散热硅胶，本来想 狠狠敲诈 好好报答他的，没有机会了 嘿嘿。 结尾后面就是打开apex测试了一下，太棒了，稳定40帧，偶尔上60，俗话说：1帧能玩 2帧流畅 3帧电竞,我的宝贝本子居然上40帧，简直就是神机啊。测试了几局以后还开出了两个金箱子，紫箱子，不愧是宝藏本子，还给我带来好运，真滴太棒啦，唯一的缺点就是风扇声更大了，仿佛回到了我和它刚见面的模样，当时它也是转的很大声，经历了这一次拆机过程以后，我学会啦！！ 就是不要自己拆机，买个冰棒给充电器让他帮我拆就行了 就这样，掰掰！期待夏天买新散热硅脂再次拆机.","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"周记","slug":"周记","permalink":"http://mrnobody233.github.io/tags/%E5%91%A8%E8%AE%B0/"}]},{"title":"flex布局","slug":"flex布局","date":"2022-04-23T08:18:52.000Z","updated":"2022-04-23T15:24:03.911Z","comments":true,"path":"2022/04/23/flex布局/","link":"","permalink":"http://mrnobody233.github.io/2022/04/23/flex%E5%B8%83%E5%B1%80/","excerpt":"","text":"flex布局原理flex 是flexible Box的缩写，意为“弹性布局”，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为flex布局。 当我们为父盒子设为flex布局以后，子元素的 float,cleat和vertical-align属性将失效。 伸缩布局 = 弹性布局 = 伸缩盒布局 = 弹性盒布局 = flex布局 总结来说就是通过给父盒子添加flex属性，来控制子盒子的位置和排序方式 常见父项属性以下有6个属性是对父元素设置的 flex-direction: 设置主轴的方向 justify-content: 设置主轴上的子元素排序方式 flex-wrap: 设置子元素是否换行 align-content: 设置侧轴的子元素的排序方式(多行) align-items: 设置侧轴上的子元素排序方式 (单行) flex-flow: 复合属性，相当于同时设置了 flex-direction 和 flex-warp flex-direction 设置主轴的方向主轴与侧轴在 flex 布局中，是分为主轴和侧轴两个方向的，同样的叫法有：行和列，x 轴 和 y 轴 默认主轴方向就是 x 轴方向，水平向右 默认侧轴是方向是 y 轴方向，水平向下 属性值flex-direction 属性决定主轴的方向 (即项目的排列方向)注意：主轴的侧轴是会变化的，就看flex-direction 设置谁为主轴，剩下的就是侧轴，而子元素是跟着主轴来排序的 属性值 说明 row 默认值从左到右 row-reverse 从右到左边 column 从上到下 column-reverse 从下到上 justify-content 设置主轴上的子元素排列方式justify-content 属性定义了项目在主轴上的对齐方式 注意：使用这个属性之前一定要确定好主轴是哪个 属性值 说明 flex-start 默认值 从头部开始 如果主轴是x轴，则从左到啊啊有 flex-end 从尾部开始排列 center 在主轴居中对齐(如果主轴是x轴则水平居中) space-around 平均剩余空间 space-between 先两边贴边 再平分剩余空间 flex-wrap 设置子元素是否换行默认情况下，项目都排在一条线上(又称 “轴线”)，flex-wrap属性定义，flex布局中默认是不换行的。 属性值 说明 nowrap 默认值，不换行 wrap 换行 align-items 设置侧轴上的子元素排序方式 (单行) 属性值 说明 flex-start 默认值 从上到下 flex-end 从下到上 center 挤在一起居中(垂直居中) stretch 拉伸 align-content 设置侧轴上的子元素排序方式 (多行)设置子项在侧轴上的排列方式并且只能用于子项出现 换行，在单行下是没有效果的 属性值 说明 flex-start 默认值在侧轴的头部开始排列 flex-end 在侧轴的尾部开始排列 space-around 子项在侧轴平分剩余空间 space-between 子项在侧轴先分布在两头，在平分剩余空间 stretch 设置子项元素高度平分父元素高度 stretch 设置子项元素高度平分元素高度 flex-flowflex-flows 是flex-direction 和 flex-wrap 的复合属性 常见子属性 flex 子项目占的份数 align-self 控制子项自己在侧轴的排列方式 order属性自定义子项的排列顺序 flex属性flex属性定义子项目分配剩余空间，用flex来表示占多少份数 1234.box{ flex:1;} align-self 控制子项自己在侧轴的排列方式align-self 属性允许单个项目与其他项目不一样的对齐方式，可覆盖 align-item 属性 默认值为 auto ，表示继承父元素的 align-items 属性 ，如果没有父元素，则等同于 stretch 123.big :nth-child(1) { align-self: center; } order 属性定义项目的排列顺序数值越小 排列越靠前 默认为 0 与z-index不同 复习经典学了忘记，现在写博客里就可以看看啦，要不是 充电器 说要卷我 我可能要很久才会 复习 flex 布局 0.0 为了感谢他 我明天和他打羽毛球要干爆他。","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"http://mrnobody233.github.io/tags/CSS/"}]},{"title":"黑马程序员-电商管理知识总结","slug":"黑马程序员-电商管理知识总结","date":"2022-04-21T10:32:51.000Z","updated":"2022-04-26T04:03:33.146Z","comments":true,"path":"2022/04/21/黑马程序员-电商管理知识总结/","link":"","permalink":"http://mrnobody233.github.io/2022/04/21/%E9%BB%91%E9%A9%AC%E7%A8%8B%E5%BA%8F%E5%91%98-%E7%94%B5%E5%95%86%E7%AE%A1%E7%90%86%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","excerpt":"","text":"使用阿里图标 把下载好的font文件放进 assets 目录下 在 main.js 中导入字体图标 import './assets/fonts/iconfont.css' 复制类名即可 &lt;el-input prefix-icon=\"iconfont icon-3702mima\"&gt;&lt;/el-input&gt; iconfont是固定写法 vue2中全局配置axios 在 main.js 中导入 axiosimport axios from \"axios\"; 设置请求的根路径axios.defaults.baseURL = 'http://127.0.0.1:8888/api/private/v1/' 把包挂载到 vue 的原型对象上Vue.prototype.$http = axios 通过 this 就可以访问原型上的 $http发起axios请求1234567login() { this.$refs.loginFormRef.validate(async value =&gt; { if (value === false) return; const {data: res} = await this.$http.post('login', this.loginForm) console.log(res) }) } 登录成功后保存 token 将 token 保存在 sessionStorage 中window.sessionStorage.setItem('token', res.data.token); 通过编程式导航跳转到主页this.$router.push('/home') 路由导航守卫控制访问权限12345678router.beforeEach((to, form, next) =&gt; { if (to.path === '/login') return next() // 获取token const tokenStr = window.sessionStorage.getItem('token') // 如果 token 是空值，则返回login页面 if (!tokenStr) return next('/login') next()}) 退出登录 清空tokenwindow.sessionStorage.clear() 跳转到登录页面this.$router.push('/login') 通过axios请求拦截器添加token123456// axios 请求拦截axios.interceptors.request.use( config =&gt; { // 为请求头对象，添加 Token 验证的 Authorization config.headers.Authorization = window.sessionStorage.getItem('token') return config} ) 如果不通过拦截器添加token是这样写的~~ 果然学了拦截器后方便了很多呐 123456// 获取菜单列表数据async getMenuList() { this.token = window.sessionStorage.getItem('token') const {data: res} = await this.$http.get('menus', {headers: {'Authorization': this.token}}) console.log(res)}","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"},{"name":"axios","slug":"axios","permalink":"http://mrnobody233.github.io/tags/axios/"}]},{"title":"axios","slug":"axios","date":"2022-04-19T03:09:31.000Z","updated":"2022-04-21T08:13:19.943Z","comments":true,"path":"2022/04/19/axios/","link":"","permalink":"http://mrnobody233.github.io/2022/04/19/axios/","excerpt":"","text":"axios 是什么东东Axios 是专注于网络数据请求的库 相比原生的XMLHttpRequest对象 ， axios 简单易用 相比jquery，axios更加轻量化，只专注于网络数据请求 axios发起GET请求axios 发起 get 请求的语法： axios.get('url', { params:{ 参数 } }).then(callback) 具体请求实例如下： 123456789101112131415// 请求的URL地址const url = 'http://www.liulongbin.top:3006/api/get'// 请求的参数对象const paramsObj = {name: 'zs', age: 20}// 调用 axios.get() 发起 GET 请求axios.get(url, {params: paramsObj}).then((res) =&gt; { // res.data 才是服务器返回的数据 let result = res.data console.log(result)}) axios发起POST请求axios.post('url',{ 参数 }).then( callback ) 具体请求实例如下： 123456789101112131415// 请求的url地址const postUrl = 'http://www.liulongbin.top:3006/api/post'// 要提交到服务器的数据const dataObj = {location: '北京', address: '顺义'}// 调用axios.post() 发起POST请求axios.post(postUrl, dataObj).then((res) =&gt; {// res.data 才是服务器发送的数据 let result = res.data console.log(result)}) 直接使用axios发起请求asiox 也提供了类似jQuery中 $.ajax()的函数，语法如下： 123456axios({ method: ' 请求类型 ', url: ' 请求的URL地址 ', data: { post数据 } params: { GET参数 }}).then(callback) 直接使用axios发起GET请求12345678910axios({ method: 'GET', url: 'http://www.liulongbin.top:3006/api/get', params: { // GET 参数要通过 params 属性提供 name: 'zs', age: 20 }}).then((res) =&gt; { console.log(res.data)}) 直接使用axios发起POST请求12345678910axios({ method: 'POST', url: 'http://www.liulongbin.top:3006/api/post', data: { // POST 数据要通过 data 属性提供 location: '北京', address: '顺义' }}).then((res) =&gt; { console.log(res.data)}) 结合 async 和 await 来使用axios 调用 axios 之后 可以使用 async/await进行简化 使用解构赋值，从axios封装的大对象中，把 data 属性解构出来 把结构出来的 data属性，使用 冒号 进行重命名，一般都重命名为 { data : res } 可以使用结构赋值 1234567891011async btnGet() { const {data: res} = await axios({ method: 'GET', url: 'http://www.liulongbin.top:3006/api/get', params: { // GET 参数要通过 params 属性提供 name: 'zs', age: 20 } }) console.log(res) }","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Ajax","slug":"Ajax","permalink":"http://mrnobody233.github.io/tags/Ajax/"}]},{"title":"凌晨校园","slug":"凌晨校园","date":"2022-04-17T16:06:15.000Z","updated":"2022-04-18T13:31:48.415Z","comments":true,"path":"2022/04/18/凌晨校园/","link":"","permalink":"http://mrnobody233.github.io/2022/04/18/%E5%87%8C%E6%99%A8%E6%A0%A1%E5%9B%AD/","excerpt":"","text":"第二次本来想在工作室过夜写会儿代码的，但是在十一点四十的时候果果超甜突然告诉我明天早上要做核酸，TNND，我真的受不了了，明明今天已经做过了，居然连续做两天，所以我准备回宿舍，不过红绿蓝并不是只有我一个人，还有一个老师也在，整个地方只有他的办公室还是亮着的，为了不让他发现我在这里，我小心的打开自己办公室的门，然后悄咪咪的溜到大门口，这个真的是高难度，因为大门太重了，开的时候会发出嘎吱嘎吱的响声，我也经常在办公室听大门的开关声来判断是否有人进来。所以结局很正常，我被他发现了，关键是我打都没打开门，因为门被锁了，而且还是磁力锁，我来这里三个学期了都没有看到他们打开磁力，今天TMD突然就打开了，然后老师就说了一句 谁？ 把我尬死在原地，我故作镇定，回答：还能出去吗？ 然后他说待会走。 然后我就默默的回到自己的办公室打开小灯开始看自己的代码，尬的我连刚刚学的Vuex传值都不会了，加上我尿急，我都快绷不住了，过了好一会儿他来了，说 走吧 ，问我为什么这么晚还没回宿舍，我说项目还有一些需要改的地方，他也没多问，出去的时候我才知道，磁力门并不是那个老师弄的，他也尝试拉了一下门，和我一样打不开，我按了一下右边的按钮就开了，接着就在外面等他锁门，拿手电筒照着他，看他锁门，尬死我了，心里想赶紧让我先走吧，然后他就让我先回去了，哎，还好他没问我这么晚了怎么回宿舍，不然我真的答不出来。 宿舍离工作室也不算很远，不过路上还是特别可怕的，第一个是太黑了一点灯都没有，第二个是太冷了，第三个就是妈的那个SB孔雀突然叫了一下，把我吓得鸡皮疙瘩都起来了，搞不明白为什么孔雀要放在我宿舍对面，现在住在这栋宿舍的人每天都在群里想着怎么杀掉这几个孔雀。 终于到了老地方，那颗支撑我回宿舍的小树，看来多锻炼还是特别有用的，对于我来说通过这个树上二楼是一件非常轻松的事情，也许是我太轻了，手臂能够把我支撑起来，就这样我安全都回去了。 第一次实际上这并不是我第一次这么晚还在学校外面溜达，在几号来着。。也就前几天吧，因为一些原因，果果超甜，胃痛患者，还有我很晚的时候在外面溜达，本来想着等老师走了以后再回工作室的，在外面溜达了好一会儿，终于来学校这么久了找到古茗的位置了，还有我去年暑假留校做比赛经常点的外卖的位置，那个炸鸡真的太好吃了，还看见了我们学校的留学生在操场用音响放音乐，如果不是封校了，我们肯定会出去溜达的，真的可惜呀，， 过了好一会我们准备回工作室了，结果发现二楼大门被锁了。。通常是一楼被锁的，我们可以从食堂小门进去，但是二楼被锁了实在就无能为力了。期间尝试了很多方法进去，结果也就我能实现，可以从厕所那里爬过去，也就爬两个小房间的高度，然后抓着钢管到男厕所窗口就可以了，我示范了一遍给他们看，但是到钢管哪里我就没爬了，太黑了，为了安全考虑我和他们一起回宿舍了，还是熟悉的位置，我第一个爬上去了，能感觉到树枝被裁剪了许多，相比之前爬难了一点点点点，但是对于他们来说就特别困难了，努力了半天，他们终于也上来了，看得我心惊胆跳的，真是捏了一把汗，如果失误了从上面摔下来，也就一条腿骨折而已，如果没站稳脑袋磕到石头了也就一辈子躺床上罢了。安全的回到了宿舍，可是 胃痛患者 并不想回自己宿舍，因为和室友关系不好什么的，所以我善心大方收留了他 ，也就是这个决定，让我尬死了一晚上 那个时候太热了，又热又闷的，我想去开空调，但是空调线没插，我想过去插线，可是那边室友已经睡着了，所以结局很明了，我把线插好了，也把室友吵醒了被骂了一顿，可以说是我今年最尬的时候了，那晚过的很煎熬，果然我还是比较适合一个人睡，如果废宅充电器在的话就好了，他可以一晚上不睡，然后让胃痛患者睡他床，不过想想也不可能，因为不知道他们宿舍怎么上二楼，不过我以后再也不会让别人和我一起挤那么小的床睡觉了。拜拜 这次写的太粗略了，很多细节都没有写，可能是这一篇生活写的太多了，而且现在已经12：48了，明天还得早起做核酸，，等过几年我突然想起来了更多细节，也许会补充上去吧？也许。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"}]},{"title":"Vuex","slug":"Vuex","date":"2022-04-14T12:22:26.000Z","updated":"2022-04-19T04:30:59.542Z","comments":true,"path":"2022/04/14/Vuex/","link":"","permalink":"http://mrnobody233.github.io/2022/04/14/Vuex/","excerpt":"","text":"Vuex 概述组件之间共享数据 父向子传值：v-bind 属性绑定 子向父传值：自定义事件 兄弟之间共享数据：EventBus $on 接收数据的那个组件 $emit 发送数据的那个组件 以上传值只适合小范围，如果需要频繁的大范围的共享就可使用vuex Vuex 是什么是实现组件全局状态(数据) 管理的一种机制，可以方便的实现组件之间数据的共享 使用Vuex统一管理状态的好处 能够在 vuex 集中管理共享的数据，易于开发和后期维护 能够高效地实现组件之间的数据共享，提高开发效率 存储在vuex中的数据都是响应式的，能够实时保持数据与页面的同步 Vuex 的基本使用1. 安装 vuex 依赖包npm i vuex -s 2. 导入 vuex 包import Vuex from 'vuex'Vue.use(Vuex) 3.创建 store 对象、1234const store = new Vuex.store({ // state 中存放的就是全局共享的数据 state:{ count: 0 }}) 4.将 store 对象挂载到 vue 实例中12345678new Vue({ el:'#app', render:h=&gt;h(app), router, // 将创建的共享数据，挂载到Vue实例中 // 所有的组件，就可以直接从 store 中获取全局的数据了 store}) vuex的核心概念Vuex中的主要核心概念如下： State Mutation Action Getter Statestate提供位移的公共数据源，所有共享的数据都要统一放到Store的State中进行存储 1234// 创建store数据源，提供唯一公共数据const store = new Vuex.Store({ state: { count: 0 }}) 组件访问State中数据的 第一种方式： 1`this.$store.state.全局数据名称 组件访问State中数据的 第二种方式： 12// 1.从 vuex 中按需导入mapState函数import { mapState } from 'vuex' 通过刚才导入的mapState函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性 1234// 2.将全局数据，映射为当前组件的计算属性computed:{ ...mapStated(['count'])} MutationMutation 用于变更 Store 中的数据。 只能通过 mutation 变更 Store 数据，不可以直接操作 Store 中的数据 通过这种方式虽然操作起来繁琐一些，但是可以集中监控所有数据的变化 123456789101112// 定义 Mutationconst store = new Vuex.store({ state:{ count: 0 }, mutations: { add(state) { // 变更状态 state.count++ } },}) 1234567// 触发mutationmethods: {btnHandler1() { // 触发mutation的第一种方式 this.$store.commit('add') }} 可以在触发mutations时传递参数 123456mutations: { add(state, step) { // 变更状态 state.count += step }}, 1234567methods: { btnHandler1() { // 在调用 commit 函数， // 触发mutations 时携带参数 this.$store.commit('addN', 3) }} this.$store.commit()是触发mutations的第一种方式，触发mutations的第二种方式： 12// 1. 从vuex中按需导入 mapMutations函数import { mapMutations } from 'vuex' 通过刚才导入的mapMutations函数 将需要的 mutations 函数 映射为当前组件的methods方法： 1234567891011// 2. 将指定的mutations函数 映射为当前组件的methods函数methods: { ...mapMutations(['sub', 'subN']), reduction1() { this.sub() }, reduction2() { this.subN(3) } } ActionAction 用于处理异步任务如果通过异步操作变更数据，必须通过Action，而不能使用Mutation，但是在Action中还是要通过触发mutation的方式间接变更数据。 定义Action 123456789101112131415161718// 只有 mutation 中定义的函数，才有权力修改 state 中的数据 mutations: { add(state) { // 不要在 mutations 函数中 执行异步操作 /* setTimeout(() =&gt; { state.count++ },1000)*/ state.count++ }, }, actions: { addAsync(context) { setTimeout(() =&gt; { // 在 actions 中,不能直接修改 state 中的数据 // 必须通过 context.commit() 触发 某个 mutation 才行 context.commit('add') }, 1000) } 触发Action 123456methods:{ handle(){ // 触发 actions 的第一种方式 this.$store.dispath('addAsync') }} 触发 actions 异步任务时携带参数: 12345678910111213mutations: { addN(state, step) { // 变更状态 state.count += step },},actions: { addNAsync(context, step) { setTimeout(() =&gt; { context.commit('addN', step) }, 1000) }}, 123btnHandlerWaitN() { this.$store.dispatch('addNAsync', 3)} this.$store.dispath() 是触发 actions 的第一种方式，触发actions的 第二种方式： 12// 1. 从vuex中按需导入 mapActions函数import { mapActions } from 'vuex' 通过刚才导入的mapActions函数，将需要的actions函数，映射为当前组件的methods方法： 123methods:{ ...mapActions(['addAsync','addNsync'])} GetterGetter 用于对Store中的数据进行加工处理形成新的数据。 Getter 可以对Store中已有的数据加工处理之后形成新的数据，类似Vue的计算属性。 Store中数据发生变化，Getter的数据也会跟着变化。 1234export default new Vuex.Store({ state: { coun 使用getters的第一种方式 1&lt;h3&gt;{{ this.$store.getters.名称 }}&lt;/h3&gt; 使用getters的第二种方式 12345678910&lt;h1&gt;{{ showNum }}&lt;/h1&gt;import { mapGetters} from 'vuex' computed: { ...mapGetters(['showNum']) },","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue计算属性-自定义事件-watch监听器","slug":"Vue计算属性-自定义事件-watch监听器","date":"2022-04-10T12:11:01.000Z","updated":"2022-04-13T12:04:21.108Z","comments":true,"path":"2022/04/10/Vue计算属性-自定义事件-watch监听器/","link":"","permalink":"http://mrnobody233.github.io/2022/04/10/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6-watch%E7%9B%91%E5%90%AC%E5%99%A8/","excerpt":"","text":"计算属性计算属性本质上就是一个function函数,它可以实时监听data中数据的变化，并return一个计算后的新值，供组件渲染DOM时使用 声明计算属性计算属性需要以function函数的形式声明到组件的computed节点中，示例代码如下 123456789101112131415161718&lt;input type=\"text\" v-model.number=\"count\"&gt;&lt;p&gt;{{count}}乘以 2 的值为：{{ plus }} &lt;/p&gt;&lt;script&gt; export default { data(){ return{ count:1, } }, computed:{ plus(){ // 计算属性，监听 data 中 count 的变化，自动计算出 count * 2 之后的新值 return this.count * 2 } } }&lt;/script&gt; 计算属性的使用注意点 计算属性必须定义在computed节点中 计算属性必须是一个function的函数 计算属性必须有 return 返回值！！ 计算属性必须当作普通属性使用 计算属性 vs 方法相对于方法来说，计算属性会缓存计算的结果，只有计算属性的依赖项发生变化时，才会重新进行运算，因此计算属性的性能更好 自定义事件在封装组件时，为了让组件的使用者可以监听到组件内状态的变化，此时需要用到组件的自定义事件 自定义事件的3个使用步骤 在封装组件时 声明自定义事件开发者为自定义组件封装的自定义事件，必须事先在emits节点中声明 1234export default{ // 1.声明自定义事件 emits:['change'],} 触发自定义事件在emits节点下声明的自定义事件，可以通过this.$emit(‘自定义事件的名称’)方法进行触发 12345678910111213141516171819202122&lt;template&gt; &lt;div&gt; &lt;p&gt;count的值是：{{ count }}&lt;/p&gt; &lt;button @click=\"add\"&gt;+1&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default{ // 1.声明自定义事件 emits:['countChange'], methods: { add() { this.count++ // 2.this.$emit() 触发自定义事件 this.$emit('countChange') } }}&lt;/script&gt; 在使用组件时监听自定义事件 在使用自定义的组件时，可以通过v-on的形式监听自定义事件。 12345678&lt;Counter @countChange=\"getCount\"&gt;&lt;/Counter&gt; methods: { getCount() { console.log('触发countChange事件') }} 自定义事件传参。在调用this.$emit()方法触发自定义事件时，可以通过第二个参数为自定义事件传参 12345678this.$emit('countChange', this.count) // 触发自定义事件时，通过第二个参数传参======================// 外界在监听countChange自定义事件时候可以通过事件处理函数的形参拿到最新的 count值 getCount(val) { console.log('触发countChange事件,count值为:' + val) } watch 监听器watch侦听器允许开发者监视数据的变化，从而针对数据的变化做待定的操作。例如监视用户名的变化并发起请求，判断用户是否可用。 watch侦听器的基本语法开发者需要在watch节点下，定义自己的侦听器，要监听那个数据项的变化，就把那个数据项的名字作为方法的名称。 形参列表中，第一个参数代表 变化后的新值 ，第二个参数是 变化之前的旧值 12345678910111213export default { data() { return { username: '', } }, watch: { username(newVal, oldVal) { console.log('新：' + newVal, '旧：' + oldVal) }, }} 小案例:检测用户名是否可用监听username值的变化，并使用axios发起Ajax请求，检测当前输入的用户名是否可用 123456789101112131415export default { data() { return { username: '', available: ' ', } },// 侦听器 watch: { async username(newVal, oldVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/${newVal}`) this.available = res.message; }, }} immediate选项默认情况下，组件在初次加载完毕后不会调用watch侦听器。如果想让watch侦听器立即被调用，则需要使用immediate选项。 非常简单 watch节点里加一个immediate:true即可 1234567891011watch: { async username(newVal, oldVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/${newVal}`) this.available = res.message; }, // 组件加载完毕后立即调用一次当前的watch侦听器 immediate:true} deep选项当watch侦听的是一个对象，如果对象中属性值发生了变化，则无法被监听到。此时需要使用deep选项 123456789101112131415161718192021export default { data() { return { username: '', available: ' ', info: { username: 'zs' } } }, watch: { info: { // handler属性是固定写法：当username发生了变化，调用handler async handle(newVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/` + newVal) this.available = res.message; }, deep: true }, }} 监听对象单个属性的变化只想监听info.username的属性变化，可以把这个访问列声明过来即可 1234567891011121314151617181920212223export default { data() { return { username: '', available: ' ', info: { username: 'zs', password:'' } } },// 侦听器 watch: { 'info.username': { // 只想监听 info.username属性值的变化 async handle(newVal) { const {data: res} = await axios.get(`https://www.escook.cn/api/finduser/` + newVal) this.available = res.message; }, deep: true }, }}","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue数据共享","slug":"Vue数据共享","date":"2022-04-10T11:39:29.000Z","updated":"2022-04-16T10:14:25.729Z","comments":true,"path":"2022/04/10/Vue数据共享/","link":"","permalink":"http://mrnobody233.github.io/2022/04/10/Vue%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/","excerpt":"","text":"组件之间的数据共享在项目开发中，组件之间的关系分为如下3种 父子关系 兄弟关系 后代关系 父子之间的数据共享父子组件之间的数据共享又分为 1. 父向子共享数据父组件通过v-bind属性绑定向子组件共享数据。同时，子组件需要使用props接收数据 父组件 123456789101112// 父组件&lt;myTest :msg=\"message\" :user=\"userinfo\"&gt;&lt;/myTest&gt;data(){ return{ message:'hello vue', userinfo:{ name:'zs', age:20 } }} 子组件 12345678910111213&lt;!-- 子组件 --&gt;&lt;template&gt; &lt;h3&gt;测试父子传值&lt;/h3&gt; &lt;p&gt;{{ msg }}&lt;/p&gt; &lt;p&gt;{{ userinfo }}&lt;/p&gt;&lt;/template&gt;&lt;script&gt;export default { name: \"MyTest\", props: ['msg', 'userinfo'],}&lt;/script&gt; 2. 子向父共享数据子组件通过自定义事件的方式向父组件共享数据。 在子组件中 先声明自定义事件 emits: ['MyTestCount'], 触发自定义事件 this.$emit('MyTestCount', this.count)123456789101112131415161718// 子组件export default { // 1. 声明自定义事件 emits: ['MyTestCount'], data() { return { count: 0 } }, methods: { add() { this.count += 1; // 2.数据发生变化时，触发自定义事件 this.$emit('MyTestCount', this.count) } }} 在 父组件中 监听子组件的自定义事件 &lt;test @MyTestCount = 'getTestCount'&gt; &lt;/test&gt; 通过形参接收子组件传递过来的数据 123456789101112131415161718192021222324&lt;!--父组件--&gt; &lt;!--1.监听子组件的自定义事件 @MyTestCount--&gt; &lt;MyTest @MyTestCount=\"getMyTestCount\"&gt;&lt;/MyTest&gt;&lt;script&gt;import MyTest from \"@/components/MyTest\";// 父组件export default { components: {MyTest,}, data() { return { count: 0, } }, methods: { getMyTestCount(val) { // 2. 通过形参，接收子组件传递过来的数据 this.count = val } }}&lt;/script&gt; 3. 父与子双向数据同步 父组件在使用子组件期间，可以使用v-model指令维护组件内外数据的双向同步 首先父组件通过属性绑定的形式，向子组件传递一个props数据1&lt;MySon v-model:num=\"count\"&gt;&lt;/MySon&gt; 接下来在子组件接收props并声明emits.注意emits需要以'update:要更新谁放谁'形式写出来，这是一个固定写法 12props:['num']emits: ['update:num'], 接下来可以调用this.$emit('update:xxx',最新的数据) 发送出去即可123add() { this.$emit('update:num', this.num + 1) } 兄弟组件之间的数据共享兄弟组件之间实现数据共享的方案是EventBus，可以接受第三方的包mitt来创建eventBus对象，从而实现兄弟组件之间的数据共享 安装mitt 依赖包 npm i mitt 创建公共的eventBus模块123456789// 导入mitt包import mitt from 'mitt'// 创建EventBus对象const bus = mitt()// 将EventBus的实例对象共享出去export default but 在数据接收方定义事件 在数据接收方调用bus.on(‘事件名’,事件处理函数)方法注册一个自定义事件 123456789101112131415161718// 导入eventBus.js模块，得到共享的bus对象import bus from '@/eventBus/eventBus.js'export default { name: \"Right\", data() { return { count: 0 } }, created() { // 调用bus.on()方法注册一个自定义事件，通过事件处理函数的形参接收数据 bus.on('countChange', (num) =&gt; { this.count = num }) }} 在数据发送方触发事件 在数据发送方，调用bus.emit(‘事件名称’,要发送的数据)方法触发自定义事件 1234567891011121314151617import bus from \"@/eventBus/eventBus.js\";export default { name: \"Left\", data() { return { num: 0 } }, methods: { addCount() { this.num++ // 调用bus.emit()方法触发自定义事件，并发送数据 bus.emit('countChange', this.num) } },}","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue路由","slug":"Vue路由","date":"2022-04-05T12:14:46.000Z","updated":"2022-04-21T13:40:54.321Z","comments":true,"path":"2022/04/05/Vue路由/","link":"","permalink":"http://mrnobody233.github.io/2022/04/05/Vue%E8%B7%AF%E7%94%B1/","excerpt":"","text":"Vue路由路由就是Hash地址与组件之间的对应关系 前端路由的工作方式 用户点击页面上的路由连接 导致了Url地址栏中Hash值发生了变化 前端路由监听到了Hash地址的变化 前端路由把当前Hash地址对应的组件渲染到浏览器中 结论：前端路由，指的是Hash 地址与组件之间的对应关系 Vue-routerVue-router是vue.js官方给出的路由解决方案。它只能结合vue项目进行使用，能够轻松的管理SPA项目中组件的切换 vue-router 3.x 只能结合vue2进行使用 vue-router 4.x 只能结合vue3进行使用 声明路由链接和占位符可以使用&lt;router-link&gt;标签来声明路由链接，并使用&lt;router-view&gt;标签来声明路由占位符 123456789&lt;template&gt; &lt;div&gt; &lt;h1&gt;App组件&lt;/h1&gt; &lt;!--声明路由连接--&gt; &lt;router-link to=\"/home\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/movie\"&gt;电影&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于&lt;/router-link&gt; &lt;/div&gt;&lt;/template&gt; 在router/main.js中导入 并注册组件 12345678910111213// 导入需要被展示的组件import Home from \"@/views/Home.vue\";import About from \"@/views/About.vue\";import Movie from \"@/views/Movie.vue\";const routes = [ // path 是hash地址 component 是要展示的组件 {path: '/home', component: Home}, {path: '/about', component: About}, {path: '/movie', component: Movie}] 路由重定向指的是：用户在访问地址A的时候，强制用户跳转到地址C，从而展示特定的组件页面 用法十分简单 通过路由规则的 redirect属性，指定一个新的路由地址，可以很方便的设置路由的重定向 1234const routes = [// path 表示需要被重定向的“原地址”，redirect表示将要被重定向到的“新地址” {path: '/', redirect: '/home'},] 嵌套路由通过路由实现组件的嵌套展示，叫做嵌套路由 声明 子路由链接和子路由占位符 1234567891011&lt;!-- 在About.vue组件中，声明tab1和tab2的子路由连接以及子路由占位符 --&gt; &lt;div class=\"about\"&gt; &lt;h1&gt;About组件&lt;/h1&gt; &lt;hr&gt; &lt;!-- 声明子路由链接 --&gt; &lt;router-link to=\"/about/tab1\"&gt;tab1&lt;/router-link&gt;&amp;nbsp; &lt;router-link to=\"/about/tab2\"&gt;tab2&lt;/router-link&gt; &lt;hr&gt; &lt;!-- 声明子路由占位符 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; 在父路由规则中，通过 children属性 嵌套声明子路由规则 123456789101112131415161718192021// 导入需要的组件import Tab1 from \"@/views/tab/Table1.vue\";import Tab2 from \"@/views/tab/Table2.vue\";const routes = [ { path: '/about', name: 'About', component: About, // 在嵌套路由中使用路由重定向 redirect:'/about/tab1', children: [ // 通过children属性嵌套子路由规则 {path: 'tab1', component: Tab1}, {path: 'tab2', component: Tab2}, ] }]！！！注意 子路由规则的path 不要以 / 开头 这样写是错误的 children:[{path:'/tab1',component:Tab1}] 路由的query传参 跳转路由并携带query参数 to的字符串写法 1&lt;router-link :to=\"`/home/message/detail?id=${m.id}$title=${m.title}`\"&gt;{{m.title}}&lt;/router-link&gt; 跳转路由并携带query参数 to的对象写法 123456789&lt;router-link :to=\"{ path:'/home/message/detail', query:{ id:m.id, title:m.title }}\"&gt; {{m.title}}&lt;/router-link&gt; 接收参数 12$.route.query.id$.route.query.title 命名路由顾名思义 就是给路由取名字 非常简单 直接加一个name就可以了 作用就是可以简化路由的跳转 使用 1{path: '/about', component: About, name: 'about'}, 简化 1234567891011121314151617&lt;!-- 简化前 需要写完整路劲 --&gt;&lt;router-link to=\"/demo/test/welcome\"&gt;欢迎&lt;/router-link&gt;&lt;!-- 简化后 直接通过名字跳转 --&gt;&lt;router-link to=\"{name:'hello'}\"&gt;欢迎&lt;/router-link&gt;&lt;!-- 检查写法配合传递参数 --&gt;&lt;router-link :to=\"{ name:'hello', query{ id:666, title:'欢迎欢迎', }}\"&gt; 欢迎 &lt;/router-link&gt; 动态路由匹配指的是把Hash地址中可变的部分定义为参数项，从而提高路由规则的复用性。在vue-router中使用英文的冒号:来定义路由的参数项 123&lt;router-link to=\"/movie/1\"&gt;电影1&lt;/router-link&gt; &amp;nbsp;&lt;router-link to=\"/movie/2\"&gt;电影2&lt;/router-link&gt; &amp;nbsp;&lt;router-link to=\"/movie/3\"&gt;电影3&lt;/router-link&gt; &amp;nbsp; 路由中的动态参数以 : 进行声明，冒号后面是动态参数的名称 1{ path: '/movie/:id',name: 'Movie',component: Movie }, 获取动态路由参数值的两种方案 $route.params参数对象 通过动态路由匹配的方式渲染出来的组件中，可以使用$route.params对象访问到动态匹配的参数值 123456&lt;template&gt; &lt;div class=\"movie\"&gt; &lt;!--$route.params 是路由的“参数对象”--&gt; &lt;h1&gt;Movie组件---------{{ $route.params.id }}&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt; 使用props接收路由参数 为了简化路由参数的获取形式，vue-router允许 路由规则中开启props传参 1234567891011121314// 在movie组件中 以props的形式接收到路由规则匹配到的参数项// 第一种写法，值为对象，该对象中所有的key-value都会以props的形式传给Movie组件 { path: '/movie/:id', name: 'Movie', component: Movie, props: {a:1,b:'hello'} },// 第二种写法，值为布尔值，如果props的值为true 就会把该路由组件收到的所有params参数，以props的形式传给Movie组件 { path: '/movie/:id', name: 'Movie', component: Movie, props: true },// 第三种写法，值为函数props($route){ return {id:$route.query.id,title:$route.query.title}} 12// 在movie组件中使用props接收路由规则中匹配到的参数项 props: ['id'] 12&lt;!-- 直接使用props中接收的路由参数 --&gt; &lt;h1&gt;Movie组件----{{id}}&lt;/h1&gt; 编程式导航通过调用API实现导航的方式，叫做编程式导航，与之对应的，通过点击链接实现导航的方式，叫做声明式导航 普通网页中点击a链接，vue项目中点击router-link都属于声明式导航 普通网页中调用location.href跳转到新页面的方式，属于编程式导航 vue-router中的编程式vue-router提供了许多编程式导航API，其中最常用的两个API分别是 this.$router.push(‘hash地址’) 跳转到指定hash地址，从而展示对应的组件 this.$router.go(数值 n) 实现导航历史的前进，后退 路由守卫路由守卫可以控制路由的访问权限 12345678910111213router.beforeEach((to, form, next) =&gt; { // to 目标路由对象 // from 当前导航正要离开的路由对象 // next 是一个函数 表示放行 const token = localStorage.getItem('token') if (to.path === '/main' &amp;&amp; !token) { // next(false) 不允许跳转 next('/login') //强制跳转到“登录页面” } else { next() // 直接放行， 允许访问“后台主页” }}) 路由器的两种工作模式 hash模式： 地址中永远带着#号 不美观 若以后将地址通过第三方手机app分享，诺app效验严格，则地址会被标记为不合法。 兼容性较好 history模式 地址干净，美观 兼容性和hash模式相比略差 应用部署上线时需要后端人员支持，解决刷新页面服务端404问题","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Vue-ref引用-作用域插槽","slug":"Vue-ref引用-作用域插槽","date":"2022-04-03T06:21:20.000Z","updated":"2022-04-03T12:21:05.710Z","comments":true,"path":"2022/04/03/Vue-ref引用-作用域插槽/","link":"","permalink":"http://mrnobody233.github.io/2022/04/03/Vue-ref%E5%BC%95%E7%94%A8-%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD/","excerpt":"","text":"ref引用ref用来辅助开发者在不依赖jQuery的情况下，获取DOM元素或组件的引用 每个vue的组件实例上，都包含一个$refs对象，里面存储着对应的DOM元素或组件的引用。默认情况下，组件的$ref指向一个空对象。 使用 ref 引用 DOM 元素 使用ref属性 为对应的DOM添加引用名称 1&lt;h1 ref=\"myh1\"&gt;App根组件&lt;/h1&gt; 通过 this.$refs.myh1可以获取到DOM元素的引用 操作DOM元素把文本颜色改为红色 1this.$refs.myh1.style.color='red' 使用 ref 引用 组件 实例 使用ref属性 为相对应的组件添加引用名称 1&lt;Counter ref=\"counterRef\"&gt;&lt;/Counter&gt; 通过 this.$refs.counterRef可以引用组件的实例 引用到组件的实例之后，就可以调用组件上的 methods 方法 1this.$refs.counterRef.reset() this.$nextTick(cb)方法 组件的$nextTick(cb)方法，会把cb回调推迟到下一个DOM更新周期之后执行，大概意思就是，等组件的DOM异步的重新渲染完成后，再执行cb回调函数，从而保证cb回调函数可以操作到最新的DOM元素。 123this.$nextTick(()=&gt;{ this.$refs.ipt.focus()}) 插槽插槽(Slot)是vue为组件封装者提供的能力。允许开发者在封装组件时，把不确定的，希望用户指定的部分定义为插槽。 可以把插槽认为是组件封装期间，为用户预留的内容的占位符 基础用法在封装组件时，可以通过&lt;slot&gt;元素定义插槽，从而为用户预留内容占位符 123456789101112&lt;template&gt; &lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--基本用法&lt;/h3&gt; &lt;hr&gt; &lt;p&gt;第一个p标签&lt;/p&gt; &lt;!-- 通过slot标签 为用户预留内容占位符(插槽) --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;p&gt;最后一个p标签&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 用户在使用组件期间 为插槽指定具体内容 1234&lt;MyCom&gt; &lt;!-- 在使用组件时，为插槽指定具体的内容 --&gt; &lt;p&gt;---用户自定义的内容---&lt;/p&gt;&lt;/MyCom&gt; 默认内容封装组件，可以为预留的&lt;slot&gt;插槽提供默认内容。如果组件的使用者没有为插槽提供任何内容，则默认内容会生效 使用方式特别简单，在标签内写上默认内容即可 123456789101112&lt;template&gt; &lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--基本用法&lt;/h3&gt; &lt;hr&gt; &lt;p&gt;第一个p标签&lt;/p&gt; &lt;slot&gt;这是默认内容&lt;/slot&gt; &lt;p&gt;最后一个p标签&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 具名插槽如果在封装组件时需要预留多个插槽节点，则需要为每个&lt;slot&gt;插槽指定具体的 name 名称。这种带有具体名称的插槽叫做”具名插槽” 12345678910111213141516&lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--基本用法&lt;/h3&gt; &lt;hr&gt;&lt;div&gt; &lt;slot name=\"title\"&gt;&lt;/slot&gt;&lt;/div&gt; &lt;div&gt; &lt;main&gt;&lt;/main&gt; &lt;/div&gt; &lt;div&gt; &lt;slot name=\"user\"&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/div&gt; 在向具名插槽提供内容的时候，我们可以在&lt;template&gt;元素上使用v-slot,并以v-slot的参数形式提供其名称 123456789&lt;MyCom&gt; &lt;template v-slot:title&gt; &lt;p&gt;鹅鹅鹅&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:user&gt; &lt;p&gt;李白&lt;/p&gt; &lt;/template&gt;&lt;/MyCom&gt; 具名插槽可以简写，(v-slot:)替换为字符#。例如 v-slot:header可以被重写为#header 作用域插槽在封装组件的过程中，可以为预留的&lt;slot&gt;插槽绑定props数据，这种带有props数据的&lt;slot&gt;就是作用域插槽 12345&lt;div class=\"com-container\"&gt; &lt;h3&gt;MyCom组件--作用域插槽&lt;/h3&gt; &lt;hr&gt; &lt;slot :info=\"userInfo\" :msg=\"message\"&gt;&lt;/slot&gt;&lt;/div&gt; v-slot:default=”任意合法名” 一般使用scope 接收 接着可以使用插值表达式渲染出来 12345&lt;MyCom&gt; &lt;template #default=\"scope\"&gt; &lt;p&gt;{{ scope.info.name }}&lt;/p&gt; &lt;/template&gt;&lt;/MyCom&gt;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"Markor","slug":"Markor","date":"2022-04-02T03:57:05.000Z","updated":"2022-04-02T03:57:52.272Z","comments":true,"path":"2022/04/02/Markor/","link":"","permalink":"http://mrnobody233.github.io/2022/04/02/Markor/","excerpt":"","text":"Markor最近想了一小问题，就是学校解封以后，如果我回家的话基本上是不会碰电脑的，虽然我会把电脑一起带回去，但是基本上都没有打开过，可能是我觉得带着有重量感，不对，是害怕我的github没有保持日常提交代码，所以为了避免这个情况，我可以使用平板来写文档，虽然提交不上去，但是回宿舍以后，我也可以躺在床上用平板来写一写自己想写的东西，这样有挺多好处的，可以避免我在床上玩手机，这样就可以玩平板了，哈哈哈哈哈，为什么想要用平板来写文档呢，写博客什么的都不是最主要的，最重要的是让我的平板键盘能有用武之地，我已经太久没有用我的平板键盘了，一直放在抽屉里积灰，这东西花了我600RMB，我也不知道当时我怎么想的，会买这么贵的东西。 好吧我突然想起来了，在我没有买显示器之前，平板一直是我的副屏，多亏了华为的多屏协同，能帮我省很多事，虽然延迟还是有一小丢丢，但是日常使用还是很给力的，即使是这样还是有缺点的，就是字太小了，我眼睛很好，但是一直看着这么小的字也是会很难受的，所以我买了显示器，果然大屏就是爽，立马抛弃了我的小平板，只用它来记笔记，我们三个一直相处的很好，直到有一天！！！我会写博客了，我为什么不把笔记写在博客里呢，所以我再次抛弃了我的平板，没有考虑平板的感受，呜呜，果然是买前生产力，买后哔哩哔哩，盖泡面，当手托，摸鱼。所以为了改变现状，我可以使用Markor来满足自己突然想写博客的欲望，这一篇博客就是使用Markor来写的，还挺像回事，如果找到更好的软件我还是会替代Markor的，哈哈哈哈哈哈，这样我的平板就不会失宠了。 日常水博客，就酱紫，拜拜。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"}]},{"title":"熬夜之旅","slug":"熬夜之旅","date":"2022-04-01T15:18:55.000Z","updated":"2022-04-01T16:03:25.378Z","comments":true,"path":"2022/04/01/熬夜之旅/","link":"","permalink":"http://mrnobody233.github.io/2022/04/01/%E7%86%AC%E5%A4%9C%E4%B9%8B%E6%97%85/","excerpt":"","text":"熬夜之旅 今天在工作室度过第一个夜晚，虽然在暑假比赛的时候已经住过另一个工作室了，但是这里还是头一次，和我一起的有社恐废宅充电器和胃病患者，比起宿舍我确实更喜欢这里，毕竟这里不需要交电费和水费，最主要的是还有空调可以吹，虽然室友都有比较好的作息时间，但在其他时间还是比较吵的，串门的比较多，所以非常感谢有这么好的环境提供给我学习和休息，今晚如果没有SB抢我的折叠床，我应该会睡的比较早。 其他的事 凌晨两点半的时候，有一个网友突然发现了我，她问我是谁，毕竟隔了四五年了，不记得我是谁也很正常，所以我稍微和她解释了一下，这样体现了给人写备注的好处。这个姑娘的也挺悲催的，所以我对她印象挺深刻，她和父母关系不好，有自残倾向，到了现在和她聊了一会，她告诉我在今年，也就是她的18岁那天，她自杀未遂，但是和父母关系好了一些，她说她重生了，我为她感到高兴，但也不敢问的太仔细，虽然她貌似想向我分享那些事情，但我还是把话题给往其他地方给放了，认识她是在一个仓鼠群里，我以前养过仓鼠，和她聊得比较好所以她加了我，并且告诉我她家里的一些事，当时我并不会安慰人，只是默默听着，让她有一个地方可以宣泄自己的压力，虽然现在也是一样，我还是不会安慰人，能感受的到别人悲伤的情绪，但也不会说什么，还可能会逃避。 扯多了，她问我怕蛇吗，我没回答，只是问她现在开始养蛇了嘛，和仓鼠放在一起不会出事吗，以及蛇没有咬过你吗，她说没有，倒是很想被咬一下试试，所以一不小心又回到了自残的话题，说自己又开始抽起了烟，本以为能缓解压力，结果压力更大了，每天晚上睡眠时间只有5小时，离她想上的大学平均分还差2分，也就是每科需要进步十分，我不敢多聊，因为太晚了，已经快凌晨3点了，所以告诉她生活的美好，以及还有很多没有碰到过的有意思的事情之类的，接着就睡了。 其实像这样的网友还有很多，以前聊的特别欢乐，突然有一天就没继续下去，也不知道是什么时候结束，但还是保存在自己的联系人里，默默的看着他们的变化，也是一种属于我自己的乐趣， 最后注意身体，不要熬夜现在是2022年4月2日00:00:57，虽然标题是熬夜之旅，实际上是我想不出标题的名字而已，就酱紫，如果我再不睡，我的折叠床就要被傻逼玷污了！就酱紫，掰掰。还有一件事，这个标签是自言自语，看看就行了，全当我放屁，掰掰。","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"}]},{"title":"Vue组件和props","slug":"Vue组件和props","date":"2022-04-01T06:50:11.000Z","updated":"2022-04-03T08:07:17.211Z","comments":true,"path":"2022/04/01/Vue组件和props/","link":"","permalink":"http://mrnobody233.github.io/2022/04/01/Vue%E7%BB%84%E4%BB%B6%E5%92%8Cprops/","excerpt":"","text":"组件组件之间可以相互引用，首先得注册后使用 如何注册注册组件的方式分为两种，全局注册 和 局部注册 被全局注册的组件，可以在全局任何一个组件内使用/ 被局部注册的组件，只能在当前注册的范围内使用 全局注册组件 在main.js 中导入需要被全局注册 的组件 1import Count from \"@/components/Count.vue\"; 调用Vue.component()方法全局注册组件 1Vue.component('Count', Count) 在app组件中使用Count组件 1&lt;Count&gt;&lt;/Count&gt; 局部注册组件 在app.vue中导入需要被局部注册的组件 1import Count from \"@/components/Count.vue\"; 在components节点下通过键值对的方式注册组件 123components: { 'Count': Count,} 在app组件中使用Count组件 1&lt;Count&gt;&lt;/Count&gt; 全局注册和局部注册的区别 被全局注册的组件，可以在全局任何一个组件内使用 被局部注册的组件，只能在当前注册的方位内使用 组件的propsprops是组件的自定义属性，组件的使用者可以通过props把数据传递到子组件内部，供子组件内部进行使用。 作用：父组件通过props向子组件传递要展示的数据 好处：提高了组件的复用性 如何声明props在封装Vue组件时，可以把动态的数据项作为props自定义属性。自定义属性可以在当前组件的模板结构中被直接使用。 在子组件中声明两个要使用的props数据 比如向外界传递一个标题，作者 可以声明一个props数组 外界可以传递指定的数据，到当前的组件中1props:['title','author'] 然后可以在DOM结构中使用title的值和author的值，使用插值表达式{{}} 将两个值渲染到里面 123456&lt;div&gt; Article组件 &lt;h3&gt;标题：{{ title }}&lt;/h3&gt; &lt;h3&gt;作者:{{ author }}&lt;/h3&gt; 抽刀断水水更流，举杯消愁愁更愁&lt;/div&gt; 接着在使用这个组件期间，可以传递两个数据的值 1&lt;Article title=\"鹅鹅鹅\" author=\"木子日天\"&gt;&lt;/Article&gt; 也可以使用v-bind属性绑定的形式，为组件动态绑定props的值 1&lt;Article :title=\"info.title\" :author=\"info.name\"&gt;&lt;/Article&gt; props验证 指的是：在封装组件时对外界传递过来的props数据进行合法性的效验，从而防止数据不合法的问题。 使用数组类型props节点的话，无法为每个props指定具体的数据类型 对象类型的props节点 使用对象类型的props节点，可以对每个props 进行数据类型的效验 对象类型的props节点，提供了多种数据验证方案 基础的类型检查 1234 props:{ // title的属性值只能是数字类型 title:Number,} 多个可能的类型 1234 props:{ // title的属性值可以是 \"字符串\" 或者 \"数字\" title:[String,Number],} 必填项效验 123456 props:{ title:{ type:String, // 表示当前属性的值必须是String字符串类型 required:true // 表示当前属性是 }} 属性默认值 123456 props:{ age:{ type:Number, // 表示当前属性的值必须是String字符串类型 default:18, // 如果有使用者没有指定 age 的值 则它的默认值为18 }} 自定义验证函数 动态组件指的是动态的切换组件的显示与隐藏。vue提供了一个内置的&lt;component&gt;组件，专门用来实现组件的动态渲染。 &lt;component&gt; 是组件的占位符 通过 is属性 动态指定 要渲染的组件名称 &lt;component is=\"要渲染的组件的名称\"&gt;&lt;/component&gt; 使用keep-alive 保持这状态默认情况下，切换动态组件时无法保持组件的状态。这样就可以使用 &lt;keep-alive&gt;组件保持动态组件的状态 使用方式非常简单 123&lt;keep-alive&gt; &lt;component :is=\"comName\"&gt;&lt;/component&gt;&lt;/keep-alive&gt;","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"不要熬夜","slug":"不要熬夜","date":"2022-03-28T14:31:41.000Z","updated":"2022-03-29T02:18:45.328Z","comments":true,"path":"2022/03/28/不要熬夜/","link":"","permalink":"http://mrnobody233.github.io/2022/03/28/%E4%B8%8D%E8%A6%81%E7%86%AC%E5%A4%9C/","excerpt":"","text":"熬夜 起因昨天和工作室的小伙伴们一起看社恐废宅充电器在玩一款新的游戏，叫做幽灵线: 东京，我们更喜欢叫他林正英模拟器 对了那个游戏长这样确实比较新颖，因为他的攻击方式是把手比作枪，用手射出子弹一样，给人眼前一亮的感觉，但是玩久了感觉有点单调，不算很耐玩的游戏，也许是它太贵了我买不起，要200多RMB。 然后我们的社恐废宅充电器就开始了今天的熬夜，他花了一晚上的时间通关了幽灵线: 东京，虽然是简单版的模式，但主要的是他通宵到到第二天中午才开始睡觉，这是他的睡姿 睡得和死了一样，这样的情况已经不是第一次了，我们也不是第一次提醒他，所以这里提前说明一下，如果他突然有一天走着走着就猝死了，希望他不要来找我，因为我已经提醒了很多次了， 接着在寒假的时候我也熬夜，但是没有他这么严重，最多熬到四五点，偶尔六点多起来去吃早餐，我记得五点半去的时候老板娘还没有准备好，所以我等到六点在去吃的，挖槽，原来早饭这么好吃，特别是那个猪血粉，等学校解封我回我奶奶家，一定得再去吃一次，现在想起来那个老板娘还是我小学同学的妈妈，她告诉我她女儿去参军了，两年以后才会回来，我倒是挺期待她能被改变成什么样，但是我最希望的是老板娘能送我瓶核桃味的早餐奶给我喝，我太喜欢喝了，噗哈哈。 最后额，今天写的这个主要是做了一个新的分类，叫做自言自语，其目的是为了水博客，和分享关于自己有意思的事情，又或者是把自己可能会忘记的日常存在这里，所以最后还是点名一下主题把，就是希望我以后能少熬点夜，不能和那个SB一样，就当为了吃到好吃的猪血粉而努力吧，就这样，晚安~","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"}]},{"title":"实用网站","slug":"实用网站","date":"2022-03-26T13:19:12.000Z","updated":"2022-04-21T13:42:13.155Z","comments":true,"path":"2022/03/26/实用网站/","link":"","permalink":"http://mrnobody233.github.io/2022/03/26/%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99/","excerpt":"","text":"实用网站我的文件夹里有许多使用的网站，但也只是放在文件夹里，乱七八糟，没有整理，所以现在放在这里，以后就可以更加方便的利用这些网站 编程类颜色网站 不知道如何配色可以看看介个网站 另一个颜色网站 这个也不错 取名鬼才不知道取什么变量名可以看看这个 阿里字库不管是网页还是PS，又或者是PPT，都可以用得上，真不错 图片类wallpaper壁纸 有许多挺不错的漂亮壁纸可以在这里看 搜图神器 可以搜索超清的好康的图片 主要我是荣耀捐赠会员 音乐类刘志进音乐直连搜索 可以在这里搜索很多音乐 外链转换工具 可以配合上一个网站获得音乐的mp3网址 影视类hwj影视 可以看各种电影和番剧 (使用手机打开会有广告，推荐打开网页版 ) 寻剧吧 也是看各种电影和番剧 (使用手机打开会有广告，推荐打开网页版 ) 蜀黍的网站 你所热爱的就是你的生活 (陈睿 吃柠檬) 油管 可以在里面找乐子0.0 要翻墙 娱乐类今天吃什么 不知道吃什么可以看看介个 Picrew 随机生成头像，我的github的头像就是这里来的，是不是很好看 qwq 要翻墙 逗比拯救世界 很多各种各样的表情包，逗比必备哦。 其他免费空间 学习html css的时候跟着pink老师找到的网站。 木子网 上传的大一下学期的期末作业，纯html和css，做的好像比现在还好看许多，果然我把css忘光了。 查看综测分 查看综测分 学校选课 学校选修网课 无聊了继续更新 拜拜","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"网站","slug":"网站","permalink":"http://mrnobody233.github.io/tags/%E7%BD%91%E7%AB%99/"},{"name":"工具","slug":"工具","permalink":"http://mrnobody233.github.io/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"Vue指令","slug":"Vue指令","date":"2022-03-26T09:33:02.000Z","updated":"2022-03-26T11:19:52.738Z","comments":true,"path":"2022/03/26/Vue指令/","link":"","permalink":"http://mrnobody233.github.io/2022/03/26/Vue%E6%8C%87%E4%BB%A4/","excerpt":"","text":"Vue指令 虽然学习完了Vue，但还有许多地方木有掌握，所以今天就来复习一下Vue还没有掌握的指令 按键修饰符 条件渲染指令 循环渲染指令 虽然只有一些内容，但还是要认真的写下去，不然就得去平板看我写的丑不拉几的字，我实在不忍心看下去，这也是在这里复习的原因之一。 按键修饰符 在监听键盘事件的时候，我们需要判断详细的按键，此时，可以为键盘相关的事件添加按键修饰符 举一个非常简单的案例，当我们在登录页面输入完密码之后，按下回车键后使用Ajax发送数据 如何实现捏？ 我们可以使用 @keyup事件 &lt;input type=\"password\" @keyup.enter=\"commitAjax\"&gt; 这样在input表单中按下回车键就可以触发方法了 非常的方便，学废了。 条件渲染指令这个好像挺简单的，既然打出来了，全当复习用了这个东西主要用来辅助开发者按需控制DOM的显示与隐藏但是条件渲染指令有两个 v-if v-show 两者区别不大 但还是要讲一讲 继续举一个简单地例子 123&lt;p v-if=\"flag\"&gt;这是被 v-if 控制的元素&lt;/p&gt;&lt;!-- -------当flag为false的时候两者都会隐藏 但是隐藏的方法不一样-------- --&gt;&lt;p v-show=\"flag\"&gt;这是被 v-show 控制的元素&lt;/p&gt; v-if 会动态创建元素或者移除v-show 则是给元素添加 display:none;样式 来实现元素的显示和隐藏 差点忘记了还有一个 v-else v-else指令必须搭配 v-if 来进行使用 否则将不会被识别 来看个简单地例子就会了 1234&lt;div v-if=\"type === 'A'\"&gt;优秀&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt;良好&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt;一般&lt;/div&gt;&lt;div v-else&gt;差&lt;/div&gt; 是不是很简单呢 循环渲染指令实际上这个才是我要复习的内容，前面两个都太简单了，虽然这个也是，看看文档就会了，但是为了以后不用看文档，所以才认真写一写吧 V-for列表渲染指令，用于开发者基于一个数组来循环渲染一个列表结构 先来看看代码 12345678data:{ // 列表数据 list[ {id: 1 ,name: '木子日天' }, {id: 2 ,name: '李日天' }, {id: 3 ,name: '木子昊' }, ]} 要循环那个DOM 就给那个加上 v-for=\"item in list\" 1234&lt;div v-for='item in list'&gt; &lt;p&gt;{{item.id}} ,{{item.name}}&lt;/p&gt;&lt;/div&gt; item 是循环的每一项list是被循环的数组 结果就是 1231,木子日天2,李日天3,木子昊 使用了v-for指定那么一定要绑定一个 :key属性 123&lt;div v-for=\"item in list\" :key=\"item.id\"&gt; &lt;p&gt;{{item.id}} ,{{item.name}}&lt;/p&gt;&lt;/div&gt; 就酱紫 拜拜","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"}]},{"title":"First_Vue_Web","slug":"First-Vue-Web","date":"2022-03-25T10:45:09.000Z","updated":"2022-03-26T09:11:36.909Z","comments":true,"path":"2022/03/25/First-Vue-Web/","link":"","permalink":"http://mrnobody233.github.io/2022/03/25/First-Vue-Web/","excerpt":"","text":"原因因为我的同学胃病患者在上学期参加了，信工的移动安卓设计比赛，并获得了二等奖，我很是心动 ，并不是心动二等奖，而是心动因为二等奖获得的雷蛇鼠标，虽然我已经买了一个比他更贵的鼠标，但是我好不爽，能白嫖为什么要买，所以我下定决心，去参加了这个学期的网站设计大赛，获得更高的奖品，至少给我一个雷蛇键盘 想法正好最近学完Vue,有用武之地，为了不让知识悄悄溜走，所以我决定使用Vue来制作本次项目，询问了举办方老师，可以使用Vue之类的东东，所以很快啊，我立马新建文件夹，可是不知道做什么类型的东西，思考许久，终于！！ 我决定做一个做烂的东西，也就是我们工作室的网站，但是是SPA（单页应用程序），想法有了，就有动力去做了。正好比赛需要上交一份PPT，也就顺便把SPA的介绍在博客里面写好，这样就不用再去百度了，我真聪明，哈哈哈哈哈哈！。 SPA（单页面应用程序）1.什么是单页面应用程序单页面应用程序 （英文名:Single Page Application）简称SPA，顾名思义，指的就是一个Web网站中只有唯一一个HTML页面，所有的功能和交互都在这唯一的一个页面内完成 2.单页面应用程序的特点单页面应用程序将所有的功能局限于一个web页面中。仅在该web页面初始化时加载相应的资源（HTML，JavaScript，CSS） 一旦页面加载完成，SPA不会因为用户的操作而进行页面的重新加载或跳转。而是利用JavaScript动态的变换HTML内容，从而实现用户的交互。 3.单页应用程序的优点良好的交互体验 单页面应用的内容的改变不需要重新加载整个页面 获取数据也是通过Ajax异步获取 没有页面之间的跳转，所以不会出现“白屏现象” 良好的前后端工作分离模式 后端专注于提供API接口，更容易实现API接口的附庸 前端专注于页面的渲染，更利于前端工程化的发展 减轻服务器的压力 服务器只需提供数据，不负责页面的合成与逻辑的处理，吞吐能力会提高几倍。 4.单页应用程序的缺点 1.首屏加载慢 2.不利于SEO 长啥样？ 说了这么久那么做的到底咋样呢？实际上不怎么地，在制作期间参考了许多网站，包括学长写过的工作室网站发现我写的实在是太垃圾了，简直就是一坨屎一样，不过好歹是我第一次完成Vue作品，也使用了大量的Vant组件和Element组件，整体看起来不算很丑（自我安慰），相信我以后技术成熟了能够更加完善这个项目，不用再参考公众号的布局。哈哈，那么就来看一看吧。 长这样。 这样。 和这样 没有全截完 但是也可以看出 制作水平很一般了。 所以还需再接再厉。拜拜~","categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://mrnobody233.github.io/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"}]},{"title":"不要被外表迷惑","slug":"不要被外表迷惑","date":"2022-03-25T05:30:58.000Z","updated":"2022-04-21T13:41:42.031Z","comments":true,"path":"2022/03/25/不要被外表迷惑/","link":"","permalink":"http://mrnobody233.github.io/2022/03/25/%E4%B8%8D%E8%A6%81%E8%A2%AB%E5%A4%96%E8%A1%A8%E8%BF%B7%E6%83%91/","excerpt":"","text":"本来这个博客很早就可以完成的，都怪我被迷惑了，因为那个网站实在是太漂亮了，我也想整一个 就是这个网站(可以点我)，他实在是太漂亮了，原来网站可以这么漂亮,所以我决定使用这个网站，但是发现他的配置文件完全看不懂，我实在是太菜了。 感觉自己白学前端了，所以我下定决心，毕业以后一定不要做程序员 还是去送外卖好了QWQ,所以今天我学废了，自己垃圾就不要去看大佬作品，否则会怀疑人生，马上自闭。 就酱紫，拜拜~~","categories":[{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"}]}],"categories":[{"name":"web前端","slug":"web前端","permalink":"http://mrnobody233.github.io/categories/web%E5%89%8D%E7%AB%AF/"},{"name":"生活","slug":"生活","permalink":"http://mrnobody233.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://mrnobody233.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"Vue","permalink":"http://mrnobody233.github.io/tags/Vue/"},{"name":"智障","slug":"智障","permalink":"http://mrnobody233.github.io/tags/%E6%99%BA%E9%9A%9C/"},{"name":"自言自语","slug":"自言自语","permalink":"http://mrnobody233.github.io/tags/%E8%87%AA%E8%A8%80%E8%87%AA%E8%AF%AD/"},{"name":"周记","slug":"周记","permalink":"http://mrnobody233.github.io/tags/%E5%91%A8%E8%AE%B0/"},{"name":"Ajax","slug":"Ajax","permalink":"http://mrnobody233.github.io/tags/Ajax/"},{"name":"CSS","slug":"CSS","permalink":"http://mrnobody233.github.io/tags/CSS/"},{"name":"axios","slug":"axios","permalink":"http://mrnobody233.github.io/tags/axios/"},{"name":"网站","slug":"网站","permalink":"http://mrnobody233.github.io/tags/%E7%BD%91%E7%AB%99/"},{"name":"工具","slug":"工具","permalink":"http://mrnobody233.github.io/tags/%E5%B7%A5%E5%85%B7/"},{"name":"项目","slug":"项目","permalink":"http://mrnobody233.github.io/tags/%E9%A1%B9%E7%9B%AE/"}]}